<script>
// v1.0.0 - https://github.com/SimonLammer/anki-persistence/blob/cd2ca88e019dc3b8f32dad623932c1eabdba7e21/script.js
if(void 0===window.Persistence){var _persistenceKey="github.com/SimonLammer/anki-persistence/",_defaultKey="_default";if(window.Persistence_sessionStorage=function(){var e=!1;try{"object"==typeof window.sessionStorage&&(e=!0,this.clear=function(){for(var e=0;e<sessionStorage.length;e++){var t=sessionStorage.key(e);0==t.indexOf(_persistenceKey)&&(sessionStorage.removeItem(t),e--)}},this.setItem=function(e,t){null==t&&(t=e,e=_defaultKey),sessionStorage.setItem(_persistenceKey+e,JSON.stringify(t))},this.getItem=function(e){return null==e&&(e=_defaultKey),JSON.parse(sessionStorage.getItem(_persistenceKey+e))},this.removeItem=function(e){null==e&&(e=_defaultKey),sessionStorage.removeItem(_persistenceKey+e)})}catch(e){}this.isAvailable=function(){return e}},window.Persistence_windowKey=function(e){var t=window[e],n=!1;"object"==typeof t&&(n=!0,this.clear=function(){t[_persistenceKey]={}},this.setItem=function(e,n){null==n&&(n=e,e=_defaultKey),t[_persistenceKey][e]=n},this.getItem=function(e){return null==e&&(e=_defaultKey),null==t[_persistenceKey][e]?null:t[_persistenceKey][e]},this.removeItem=function(e){null==e&&(e=_defaultKey),delete t[_persistenceKey][e]},null==t[_persistenceKey]&&this.clear()),this.isAvailable=function(){return n}},window.Persistence=new Persistence_sessionStorage,Persistence.isAvailable()||(window.Persistence=new Persistence_windowKey("py")),!Persistence.isAvailable()){var titleStartIndex=window.location.toString().indexOf("title"),titleContentIndex=window.location.toString().indexOf("main",titleStartIndex);titleStartIndex>0&&titleContentIndex>0&&titleContentIndex-titleStartIndex<10&&(window.Persistence=new Persistence_windowKey("qt"))}}
</script>
<div id="backGo" class="besogo-editor">{{SGF}}</div>

<script>
var goFirst = true;
var realstones = false;
var randVar = false;  // If Persistence is enabled, this setting is ignored.
var probVar = 0;

var solvedColour = "limegreen"; // If Persistence is enabled, this setting is ignored.

if (Persistence.isAvailable()) {
    solvedColour = Persistence.getItem("solvedColour");
    randVar = Persistence.getItem("rnd");
    if (randVar) {
        probVar = Persistence.getItem("var");
    }
    Persistence.clear();
}


<!-- Besogo Copyright (c) 2015-2018 Ye Wang under MIT license -->
function nextMove() {
    document.querySelector('[title="Next node"]').click();
}

function checkComment(comment) {
    const goodAnswers = ["CORRECT", "RIGHT"];
    const badAnswers = ["INCORRECT", "WRONG", "FAIL"];
    if (!comment) return 0;
    for (let answer of goodAnswers) {
        if (comment.toUpperCase().startsWith(answer)) {
            return(1);
        }
    };
    for (let answer of badAnswers) {
        if (comment.toUpperCase().startsWith(answer)) {
            return(-1);
        }
    };
    return(0);
}
if (typeof myTimeout !== 'undefined') {
    clearTimeout(myTimeout);
};
(function() {
    'use strict';
    var besogo = window.besogo = window.besogo || {}; // Establish our namespace
    besogo.VERSION = '0.0.2-alpha';

    besogo.create = function(container, options) {
        var editor, // Core editor object
            resizer, // Auto-resizing function
            boardDiv, // Board display container
            panelsDiv, // Parent container of panel divs
            makers = { // Map to panel creators
                control: besogo.makeControlPanel,
                names: besogo.makeNamesPanel,
                comment: besogo.makeCommentPanel,
                tool: besogo.makeToolPanel,
                tree: besogo.makeTreePanel,
                file: besogo.makeFilePanel
            },
            insideText = container.textContent || container.innerText || '',
            i, panelName; // Scratch iteration variables

        container.className += ' besogo-container'; // Marks this div as initialized

        // Process options and set defaults
        options = options || {}; // Makes option checking simpler
        options.size = besogo.parseSize(options.size || 19);
        options.coord = options.coord || 'none';
        options.tool = options.tool || 'auto';
        if (options.panels === '') {
            options.panels = [];
        }
        options.panels = options.panels || 'control+names+comment+tool+tree+file';
        if (typeof options.panels === 'string') {
            options.panels = options.panels.split('+');
        }
        options.path = options.path || '';
        if (options.shadows === undefined) {
            options.shadows = 'auto';
        } else if (options.shadows === 'off') {
            options.shadows = false;
        }

        // Make the core editor object
        editor = besogo.makeEditor(options.size.x, options.size.y);
        editor.setTool(options.tool);
        editor.setCoordStyle(options.coord);
        if (realstones) { // Using realistic stones
            editor.REAL_STONES = true;
            editor.SHADOWS = options.shadows;
        } else { // SVG stones
            editor.SHADOWS = (options.shadows && options.shadows !== 'auto');
        }

        if (!options.nokeys) { // Add keypress handler unless nokeys option is truthy
            addKeypressHandler(container, editor);
        }

        if (options.sgf) { // Load SGF file from URL
            try {
                fetchParseLoad(options.sgf, editor, options.path);
            } catch (e) {
                // Silently fail on network error
            }
        } else if (insideText.match(/\s*\(\s*;/)) { // Text content looks like an SGF file
            parseAndLoad(insideText, editor);
            navigatePath(editor, options.path); // Navigate editor along path
        }

        if (typeof options.variants === 'number' || typeof options.variants === 'string') {
            editor.setVariantStyle(+options.variants); // Converts to number
        }

        while (container.firstChild) { // Remove all children of container
            container.removeChild(container.firstChild);
        }

        boardDiv = makeDiv('besogo-board'); // Create div for board display
        besogo.makeBoardDisplay(boardDiv, editor); // Create board display

        if (!options.nowheel) { // Add mousewheel handler unless nowheel option is truthy
            addWheelHandler(boardDiv, editor);
        }

        if (options.panels.length > 0) { // Only create if there are panels to add
            panelsDiv = makeDiv('besogo-panels');
            for (i = 0; i < options.panels.length; i++) {
                panelName = options.panels[i];
                if (makers[panelName]) { // Only add if creator function exists
                    makers[panelName](makeDiv('besogo-' + panelName, panelsDiv), editor);
                }
            }
            if (!panelsDiv.firstChild) { // If no panels were added
                container.removeChild(panelsDiv); // Remove the panels div
                panelsDiv = false; // Flags panels div as removed
            }
        }

        options.resize = options.resize || 'auto';
        if (options.resize === 'auto') { // Add auto-resizing unless resize option is truthy
            resizer = function() {
                var windowHeight = window.innerHeight, // Viewport height
                    // Calculated width of parent element
                    parentWidth = parseFloat(getComputedStyle(container).width),
                    maxWidth = +(options.maxwidth || (window.innerWidth < 1400) ? 700 : 1400),
                    orientation = options.orient || 'auto',

                    portraitRatio = +(options.portratio || 200) / 100,
                    landscapeRatio = +(options.landratio || 200) / 100,
                    minPanelsWidth = +(options.minpanelswidth || 350),
                    minPanelsHeight = +(options.minpanelsheight || 400),
                    minLandscapeWidth = +(options.transwidth || 1400),

                    // Initial width parent
                    width = (maxWidth > 0 && maxWidth < parentWidth) ? maxWidth : parentWidth,
                    height; // Initial height is undefined

                // Determine orientation if 'auto' or 'view'
                if (orientation !== 'portrait' && orientation !== 'landscape') {
                    if (width < minLandscapeWidth || (orientation === 'view' && width < windowHeight)) {
                        orientation = 'portrait';
                    } else {
                        orientation = 'landscape';
                    }
                }

                if (orientation === 'portrait') { // Portrait mode
                    if (!isNaN(portraitRatio)) {
                        height = portraitRatio * width;
                        if (panelsDiv) {
                            height = (height - width < minPanelsHeight) ? width + minPanelsHeight : height;
                        }
                    } // Otherwise, leave height undefined
                } else if (orientation === 'landscape') { // Landscape mode
                    if (!panelsDiv) { // No panels div
                        height = width; // Square overall
                    } else if (isNaN(landscapeRatio)) {
                        height = windowHeight;
                    } else { // Otherwise use ratio
                        height = width / landscapeRatio;
                    }

                    if (panelsDiv) {
                        // Reduce height to ensure minimum width of panels div
                        height = (width < height + minPanelsWidth) ? (width - minPanelsWidth) : height;
                    }
                }

                setDimensions(width, height);
                container.style.width = width + 'px';
            };
            window.addEventListener("resize", resizer);
            resizer(); // Initial div sizing
        } else if (options.resize === 'fixed') {
            setDimensions(container.clientWidth, container.clientHeight);
        }

        // Sets dimensions with optional height param
        function setDimensions(width, height) {
            if (height && width > height) { // Landscape mode
                container.style['flex-direction'] = 'row';
                boardDiv.style.height = (height - 12) + 'px';
                boardDiv.style.width = (height - 12) + 'px';
                if (panelsDiv) {
                    panelsDiv.style.height = height + 'px';
                    panelsDiv.style.width = (width - height) + 'px';
                }
            } else { // Portrait mode (implied if height is missing)
                container.style['flex-direction'] = 'column';
                boardDiv.style.height = (width - 12) + 'px';
                boardDiv.style.width = (width - 12) + 'px';
                if (panelsDiv) {
                    if (height) { // Only set height if param present
                        panelsDiv.style.height = (height - width) + 'px';
                    }
                    panelsDiv.style.width = width + 'px';
                }
            }
        }

        // Creates and adds divs to specified parent or container
        function makeDiv(className, parent) {
            var div = document.createElement("div");
            if (className) {
                div.className = className;
            }
            parent = parent || container;
            parent.appendChild(div);
            return div;
        }
    }; // END function besogo.create

    // Parses size parameter from SGF format
    besogo.parseSize = function(input) {
        var matches,
            sizeX,
            sizeY;

        input = (input + '').replace(/\s/g, ''); // Convert to string and remove whitespace

        matches = input.match(/^(\d+):(\d+)$/); // Check for #:# pattern
        if (matches) { // Composed value pattern found
            sizeX = +matches[1]; // Convert to numbers
            sizeY = +matches[2];
        } else if (input.match(/^\d+$/)) { // Check for # pattern
            sizeX = +input; // Convert to numbers
            sizeY = +input; // Implied square
        } else { // Invalid input format
            sizeX = sizeY = 19; // Default size value
        }
        if (sizeX > 52 || sizeX < 1 || sizeY > 52 || sizeY < 1) {
            sizeX = sizeY = 19; // Out of range, set to default
        }

        return {
            x: sizeX,
            y: sizeY
        };
    };

    // Automatically converts document elements into besogo instances
    besogo.autoInit = function() {
        var allDivs = document.getElementsByTagName('div'), // Live collection of divs
            targetDivs = [], // List of divs to auto-initialize
            options, // Structure to hold options
            i, j, attrs; // Scratch iteration variables

        for (i = 0; i < allDivs.length; i++) { // Iterate over all divs
            if ((hasClass(allDivs[i], 'besogo-editor') || // Has an auto-init class
                    hasClass(allDivs[i], 'besogo-viewer') ||
                    hasClass(allDivs[i], 'besogo-diagram')) &&
                !hasClass(allDivs[i], 'besogo-container')) { // Not already initialized
                targetDivs.push(allDivs[i]);
            }
        }

        for (i = 0; i < targetDivs.length; i++) { // Iterate over target divs
            options = {}; // Clear the options struct
            if (hasClass(targetDivs[i], 'besogo-editor')) {
                options.panels = ['control', 'names', 'comment', 'tool', 'tree'];
                options.tool = 'auto';
            } else if (hasClass(targetDivs[i], 'besogo-viewer')) {
                options.panels = ['control', 'names', 'comment'];
                options.tool = 'navOnly';
            } else if (hasClass(targetDivs[i], 'besogo-diagram')) {
                options.panels = [];
                options.tool = 'navOnly';
            }

            attrs = targetDivs[i].attributes;
            for (j = 0; j < attrs.length; j++) { // Load attributes as options
                options[attrs[j].name] = attrs[j].value;
            }
            besogo.create(targetDivs[i], options);
        }

        function hasClass(element, str) {
            return (element.className.split(' ').indexOf(str) !== -1);
        }
    };

    // Sets up keypress handling
    function addKeypressHandler(container, editor) {
        if (!container.getAttribute('tabindex')) {
            container.setAttribute('tabindex', '0'); // Set tabindex to allow div focusing
        }

        container.addEventListener('keydown', function(evt) {
            evt = evt || window.event;
            switch (evt.keyCode) {
                case 33: // page up
                    editor.prevNode(10);
                    break;
                case 34: // page down
                    editor.nextNode(10);
                    break;
                case 35: // end
                    editor.nextNode(-1);
                    break;
                case 36: // home
                    editor.prevNode(-1);
                    break;
                case 37: // left
                    editor.prevNode(1);
                    break;
                case 38: // up
                    editor.nextSibling(-1);
                    break;
                case 39: // right
                    editor.nextNode(1);
                    break;
                case 40: // down
                    editor.nextSibling(1);
                    break;
                case 46: // delete
                    editor.cutCurrent();
                    break;
            } // END switch (evt.keyCode)
            if (evt.keyCode >= 33 && evt.keyCode <= 40) {
                evt.preventDefault(); // Suppress page nav controls
            }
        }); // END func() and addEventListener
    } // END function addKeypressHandler

    // Sets up mousewheel handling
    function addWheelHandler(boardDiv, editor) {
        boardDiv.addEventListener('wheel', function(evt) {
            evt = evt || window.event;
            if (evt.deltaY > 0) {
                editor.nextNode(1);
                evt.preventDefault();
            } else if (evt.deltaY < 0) {
                editor.prevNode(1);
                evt.preventDefault();
            }
        });
    }

    // Parses SGF string and loads into editor
    function parseAndLoad(text, editor) {
        var sgf;
        try {
            sgf = besogo.parseSgf(text);
        } catch (error) {
            return; // Silently fail on parse error
        }
        autoCropSgf(sgf, editor);
        besogo.loadSgf(sgf, editor);
    }

    function autoCropSgf(sgf, editor) {
        var minX = 53, minY = 53, maxX = 0, maxY = 0;
        var originalSizeX = 19, originalSizeY = 19;

        // Find original size
        for(var i=0; i<sgf.props.length; i++) {
            if (sgf.props[i].id === 'SZ') {
                var size = besogo.parseSize(sgf.props[i].values[0]);
                originalSizeX = size.x;
                originalSizeY = size.y;
                break;
            }
        }
        
        function charToNum(c) {
            if (c >= 'a' && c <= 'z') return c.charCodeAt(0) - 96;
            if (c >= 'A' && c <= 'Z') return c.charCodeAt(0) - 38;
            return 0;
        }
        
        function numToChar(n) {
            if (n >= 1 && n <= 26) return String.fromCharCode(n + 96);
            if (n >= 27 && n <= 52) return String.fromCharCode(n + 38);
            return '';
        }

        function getCoords(str) {
            if (!str || str.length < 2) return null;
            var x = charToNum(str.charAt(0));
            var y = charToNum(str.charAt(1));
            return {x: x, y: y};
        }

        function findBounds(node) {
            for (var i = 0; i < node.props.length; i++) {
                var p = node.props[i];
                if (['B', 'W', 'AB', 'AW', 'AE', 'CR', 'SQ', 'TR', 'MA', 'M', 'SL', 'LB', 'L'].indexOf(p.id) !== -1) {
                    for (var j = 0; j < p.values.length; j++) {
                        var v = p.values[j];
                        var parts = v.split(':');
                        for (var k = 0; k < parts.length; k++) {
                            var c = getCoords(parts[k].substring(0, 2));
                            if (c) {
                                if (c.x < minX) minX = c.x;
                                if (c.x > maxX) maxX = c.x;
                                if (c.y < minY) minY = c.y;
                                if (c.y > maxY) maxY = c.y;
                            }
                        }
                    }
                }
            }
            for (var i = 0; i < node.children.length; i++) {
                findBounds(node.children[i]);
            }
        }

        findBounds(sgf);

        if (minX > maxX || minY > maxY) return;

        // Determine crop info before shifting
        // If minX > 1, then left side is cropped (not a real edge)
        // If maxX < originalSizeX, then right side is cropped
        if (editor) {
            var crop = {
                left: minX === 1,
                right: maxX === originalSizeX,
                top: minY === 1,
                bottom: maxY === originalSizeY,
                shiftX: Math.max(1, minX - 1) - 1,
                shiftY: Math.max(1, minY - 1) - 1,
                originalSizeX: originalSizeX,
                originalSizeY: originalSizeY
            };

            // Apply transformations to crop info to match probVar
            // 1. Horizontal Flip
            if (probVar & 1) {
                var tmp = crop.left;
                crop.left = crop.right;
                crop.right = tmp;
            }
            // 2. Vertical Flip
            if (probVar & 2) {
                var tmp = crop.top;
                crop.top = crop.bottom;
                crop.bottom = tmp;
            }
            // 3. Diagonal Flip (Swap X and Y)
            if (probVar & 4) {
                // Left (min x) <-> Top (min y)
                var tmp = crop.left;
                crop.left = crop.top;
                crop.top = tmp;
                // Right (max x) <-> Bottom (max y)
                tmp = crop.right;
                crop.right = crop.bottom;
                crop.bottom = tmp;
            }

            editor.cropInfo = crop;
        }

        minX = Math.max(1, minX - 1);
        minY = Math.max(1, minY - 1);
        maxX = maxX + 1; 
        maxY = maxY + 1;

        var shiftX = minX - 1;
        var shiftY = minY - 1;
        var newSizeX = maxX - minX + 1;
        var newSizeY = maxY - minY + 1;
        
        if (newSizeX < 1) newSizeX = 1;
        if (newSizeY < 1) newSizeY = 1;

        var szProp = null;
        for(var i=0; i<sgf.props.length; i++) {
            if (sgf.props[i].id === 'SZ') {
                szProp = sgf.props[i];
                break;
            }
        }
        if (!szProp) {
            szProp = {id: 'SZ', values: []};
            sgf.props.push(szProp);
        }
        szProp.values[0] = newSizeX + ':' + newSizeY;

        function shiftCoords(node) {
            for (var i = 0; i < node.props.length; i++) {
                var p = node.props[i];
                if (['B', 'W', 'AB', 'AW', 'AE', 'CR', 'SQ', 'TR', 'MA', 'M', 'SL', 'LB', 'L'].indexOf(p.id) !== -1) {
                    for (var j = 0; j < p.values.length; j++) {
                        var v = p.values[j];
                        var parts = v.split(':');
                        var newV = "";
                        for (var k = 0; k < parts.length; k++) {
                            var c = getCoords(parts[k].substring(0, 2));
                            if (c) {
                                c.x -= shiftX;
                                c.y -= shiftY;
                                var newCoordStr = numToChar(c.x) + numToChar(c.y);
                                if (parts[k].length > 2) {
                                    newCoordStr += parts[k].substring(2);
                                }
                                if (k > 0) newV += ":";
                                newV += newCoordStr;
                            } else {
                                    if (parts[k] === "") {
                                        if (k > 0) newV += ":";
                                        newV += ""; 
                                    }
                            }
                        }
                        p.values[j] = newV;
                    }
                }
            }
            for (var i = 0; i < node.children.length; i++) {
                shiftCoords(node.children[i]);
            }
        }

        shiftCoords(sgf);
    }

    // Fetches text file at url from same domain
    function fetchParseLoad(url, editor, path) {
        var http = new XMLHttpRequest();

        http.onreadystatechange = function() {
            if (http.readyState === 4 && http.status === 200) { // Successful fetch
                parseAndLoad(http.responseText, editor);
                navigatePath(editor, path);
            }
        };
        http.overrideMimeType('text/plain'); // Prevents XML parsing and warnings
        http.open("GET", url, true); // Asynchronous load
        http.send();
    }

    function navigatePath(editor, path) {
        var subPaths,
            i, j; // Scratch iteration variables

        path = path.split(/[Nn]+/); // Split into parts that start in next mode
        for (i = 0; i < path.length; i++) {
            subPaths = path[i].split(/[Bb]+/); // Split on switches into branch mode
            executeMoves(subPaths[0], false); // Next mode moves
            for (j = 1; j < subPaths.length; j++) { // Intentionally starting at 1
                executeMoves(subPaths[j], true); // Branch mode moves
            }
        }

        function executeMoves(part, branch) {
            var i;
            part = part.split(/\D+/); // Split on non-digits
            for (i = 0; i < part.length; i++) {
                if (part[i]) { // Skip empty strings
                    if (branch) { // Branch mode
                        if (editor.getCurrent().children.length) {
                            editor.nextNode(1);
                            editor.nextSibling(part[i] - 1);
                        }
                    } else { // Next mode
                        editor.nextNode(+part[i]); // Converts to number
                    }
                }
            }
        }
    }

})(); // END closure
    besogo.makeBoardDisplay = function(container, editor) {
        'use strict';
        var CELL_SIZE = 88, // Including line width
            COORD_MARGIN = 75, // Margin for coordinate labels
            EXTRA_MARGIN = 6, // Extra margin on the edge of board
            BOARD_MARGIN, // Total board margin

            // Board size parameters
            sizeX = editor.getCurrent().getSize().x,
            sizeY = editor.getCurrent().getSize().y,

            svg, // Holds the overall board display SVG element
            stoneGroup, // Group for stones
            markupGroup, // Group for markup
            hoverGroup, // Group for hover layer
            markupLayer, // Array of markup layer elements
            hoverLayer, // Array of hover layer elements

            randIndex, // Random index for stone images

            TOUCH_FLAG = false; // Flag for touch interfaces

        initializeBoard(editor.getCoordStyle()); // Initialize SVG element and draw the board
        container.appendChild(svg); // Add the SVG element to the document
        editor.addListener(update); // Register listener to handle editor/game state updates
        redrawAll(editor.getCurrent()); // Draw stones, markup and hover layer

        // Set listener to detect touch interfaces
        container.addEventListener('touchstart', setTouchFlag);

        // Function for setting the flag for touch interfaces
        function setTouchFlag() {
            TOUCH_FLAG = true; // Set flag to prevent needless function calls
            hoverLayer = []; // Drop hover layer references, kills events
            svg.removeChild(hoverGroup); // Remove hover group from SVG
            // Remove self when done
            container.removeEventListener('touchstart', setTouchFlag);
        }

        // Initializes the SVG and draws the board
        function initializeBoard(coord) {
            drawBoard(coord); // Initialize the SVG element and draw the board

            stoneGroup = besogo.svgEl("g");
            markupGroup = besogo.svgEl("g");

            svg.appendChild(stoneGroup); // Add placeholder group for stone layer
            svg.appendChild(markupGroup); // Add placeholder group for markup layer

            if (!TOUCH_FLAG) {
                hoverGroup = besogo.svgEl("g");
                svg.appendChild(hoverGroup);
            }

            addEventTargets(); // Add mouse event listener layer

            if (editor.REAL_STONES) { // Generate index for realistic stone images
                randomizeIndex();
            }
        }

        // Callback for board display redraws
        function update(msg) {
            var current = editor.getCurrent(),
                currentSize = current.getSize(),
                reinit = false, // Board redraw flag
                oldSvg = svg;

            // Check if board size has changed
            if (currentSize.x !== sizeX || currentSize.y !== sizeY || msg.coord) {
                sizeX = currentSize.x;
                sizeY = currentSize.y;
                initializeBoard(msg.coord || editor.getCoordStyle()); // Reinitialize board
                container.replaceChild(svg, oldSvg);
                reinit = true; // Flag board redrawn
            }

            // Redraw stones only if needed
            if (reinit || msg.navChange || msg.stoneChange) {
                redrawStones(current);
                redrawMarkup(current);
                redrawHover(current);
            } else if (msg.markupChange) {
                redrawMarkup(current);
                redrawHover(current);
            } else if (msg.tool || msg.label) {
                redrawHover(current);
            }
        }

        function redrawAll(current) {
            redrawStones(current);
            redrawMarkup(current);
            redrawHover(current);
        }

        // Initializes the SVG element and draws the board
        function drawBoard(coord) {
            var boardWidth,
                boardHeight,
                string = "", // Path string for inner board lines
                i, // Scratch iteration variable
                crop = editor.cropInfo || { left: true, right: true, top: true, bottom: true };

            BOARD_MARGIN = (coord === 'none' ? 0 : COORD_MARGIN) + EXTRA_MARGIN;
            boardWidth = 2 * BOARD_MARGIN + sizeX * CELL_SIZE;
            boardHeight = 2 * BOARD_MARGIN + sizeY * CELL_SIZE;

            svg = besogo.svgEl("svg", { // Initialize the SVG element
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + boardWidth + " " + boardHeight
            });

            svg.appendChild(besogo.svgEl("rect", { // Fill background color
                width: boardWidth,
                height: boardHeight,
                'class': 'besogo-svg-board'
            }));

            // Horizontal lines
            for (i = 1; i <= sizeY; i++) {
                if (i === 1 && !crop.top) continue;
                if (i === sizeY && !crop.bottom) continue;
                string += "M" + svgPos(1) + "," + svgPos(i) + "h" + CELL_SIZE * (sizeX - 1);
            }
            // Vertical lines
            for (i = 1; i <= sizeX; i++) {
                if (i === 1 && !crop.left) continue;
                if (i === sizeX && !crop.right) continue;
                string += "M" + svgPos(i) + "," + svgPos(1) + "v" + CELL_SIZE * (sizeY - 1);
            }

            svg.appendChild(besogo.svgEl("path", { // Draw inner lines of board
                d: string,
                'class': 'besogo-svg-lines'
            }));

            drawHoshi(); // Draw the hoshi points
            if (coord !== 'none') {
                drawCoords(coord); // Draw the coordinate labels
            }
        }

        // Draws coordinate labels on the board
        function drawCoords(coord) {
            var labels = besogo.coord[coord](sizeX, sizeY),
                shift = COORD_MARGIN + 10,
                i, x, y; // Scratch iteration variable

            for (i = 1; i <= sizeX; i++) { // Draw column coordinate labels
                x = svgPos(i);
                drawCoordLabel(x, svgPos(1) - shift, labels.x[i]);
                drawCoordLabel(x, svgPos(sizeY) + shift, labels.x[i]);
            }

            for (i = 1; i <= sizeY; i++) { // Draw row coordinate labels
                y = svgPos(i);
                drawCoordLabel(svgPos(1) - shift, y, labels.y[i]);
                drawCoordLabel(svgPos(sizeX) + shift, y, labels.y[i]);
            }

            function drawCoordLabel(x, y, label) {
                var element = besogo.svgEl("text", {
                    x: x,
                    y: y,
                    dy: ".65ex", // Seems to work for vertically centering these fonts
                    "font-size": 32,
                    "text-anchor": "middle", // Horizontal centering
                    "font-family": "Helvetica, Arial, sans-serif",
                    fill: 'black'
                });
                element.appendChild(document.createTextNode(label));
                svg.appendChild(element);
            }
        }

        // Draws hoshi onto the board at procedurally generated locations
        function drawHoshi() {
            var pathStr = ""; // Path string for drawing star points
            var crop = editor.cropInfo || {};
            
            // Use original size if cropped, otherwise current size.
            // Note: originalSizeX/Y are unrotated.
            var ox = crop.originalSizeX || sizeX;
            var oy = crop.originalSizeY || sizeY;
            
            // If crop info is missing (e.g. uncropped board), we need to ensure ox/oy match the UNROTATED dimensions
            // if probVar & 4 is set.
            // sizeX/sizeY are currently displayed dimensions (rotated if probVar & 4).
            // If no crop info, then unrotated dimensions are:
            if (!crop.originalSizeX && (probVar & 4)) {
                ox = sizeY;
                oy = sizeX;
            }

            var points = [];

            if (ox % 2 && oy % 2) { // Draw center hoshi if both dimensions are odd
                var cx = (ox - 1) / 2 + 1; 
                var cy = (oy - 1) / 2 + 1;
                points.push({x: cx, y: cy});

                if (ox >= 17 && oy >= 17) { // Draw side hoshi if at least 17x17 and odd
                    points.push({x: 4, y: cy});
                    points.push({x: ox - 3, y: cy});
                    points.push({x: cx, y: 4});
                    points.push({x: cx, y: oy - 3});
                }
            }

            if (ox >= 11 && oy >= 11) { // Corner hoshi at (4, 4) for larger sizes
                points.push({x: 4, y: 4});
                points.push({x: 4, y: oy - 3});
                points.push({x: ox - 3, y: 4});
                points.push({x: ox - 3, y: oy - 3});
            } else if (ox >= 8 && oy >= 8) { // Corner hoshi at (3, 3) for medium sizes
                points.push({x: 3, y: 3});
                points.push({x: 3, y: oy - 2});
                points.push({x: ox - 2, y: 3});
                points.push({x: ox - 2, y: oy - 2});
            }

            // Transform points to cropped and flipped coordinates
            var shiftX = (crop.shiftX !== undefined) ? crop.shiftX : 0;
            var shiftY = (crop.shiftY !== undefined) ? crop.shiftY : 0;
            
            // Dimensions of the unrotated cropped board
            // If probVar & 4, sizeX/sizeY are swapped relative to unrotated.
            var unrotW = (probVar & 4) ? sizeY : sizeX;
            var unrotH = (probVar & 4) ? sizeX : sizeY;

            for (var k = 0; k < points.length; k++) {
                var p = points[k];
                // Apply Shift (to get to unrotated cropped coords)
                var tx = p.x - shiftX;
                var ty = p.y - shiftY;

                // Check if point is within the visible cropped area
                if (tx >= 1 && tx <= unrotW && ty >= 1 && ty <= unrotH) {
                    // Apply ProbVar flips/rotations to map to display coordinates
                    // Logic mirrors lettersToCoords
                    if (probVar & 1) { tx = unrotW + 1 - tx; }
                    if (probVar & 2) { ty = unrotH + 1 - ty; }
                    if (probVar & 4) {
                        var tmp = tx;
                        tx = ty;
                        ty = tmp;
                    }
                    drawStar(tx, ty);
                }
            }

            if (pathStr) { // Only need to add if hoshi drawn
                svg.appendChild(besogo.svgEl('path', { // Drawing circles via path points
                    d: pathStr, // Hack to allow radius adjustment via stroke-width
                    'stroke-linecap': 'round', // Makes the points round
                    'class': 'besogo-svg-hoshi'
                }));
            }

            function drawStar(i, j) { // Extend path string to draw star point
                pathStr += "M" + svgPos(i) + ',' + svgPos(j) + 'l0,0'; // Draws a point
            }
        }

        // Remakes the randomized index for stone images
        function randomizeIndex() {
            var maxIndex = besogo.BLACK_STONES * besogo.WHITE_STONES,
                i, j;

            randIndex = [];
            for (i = 1; i <= sizeX; i++) {
                for (j = 1; j <= sizeY; j++) {
                    randIndex[fromXY(i, j)] = Math.floor(Math.random() * maxIndex);
                }
            }
        }

        // Adds a grid of squares to register mouse events
        function addEventTargets() {
            var element,
                i, j;

            for (i = 1; i <= sizeX; i++) {
                for (j = 1; j <= sizeY; j++) {
                    element = besogo.svgEl("rect", { // Make a transparent event target
                        x: svgPos(i) - CELL_SIZE / 2,
                        y: svgPos(j) - CELL_SIZE / 2,
                        width: CELL_SIZE,
                        height: CELL_SIZE,
                        opacity: 0
                    });

                    // Add event listeners, using closures to decouple (i, j)
                    element.addEventListener("click", handleClick(i, j));

                    if (!TOUCH_FLAG) { // Skip hover listeners for touch interfaces
                        element.addEventListener("mouseover", handleOver(i, j));
                        element.addEventListener("mouseout", handleOut(i, j));
                    }

                    svg.appendChild(element);
                }
            }
        }

        function handleClick(i, j) { // Returns function for click handling
            return function(event) {
                // Call click handler in editor
                editor.click(i, j, event.ctrlKey, event.shiftKey);
                if (!TOUCH_FLAG) {
                    (handleOver(i, j))(); // Ensures that any updated tool is visible
                }
            };
        }

        function handleOver(i, j) { // Returns function for mouse over
            return function() {
                var element = hoverLayer[fromXY(i, j)];
                if (element) { // Make tool action visible on hover over
                    element.setAttribute('visibility', 'visible');
                }
            };
        }

        function handleOut(i, j) { // Returns function for mouse off
            return function() {
                var element = hoverLayer[fromXY(i, j)];
                if (element) { // Make tool action invisible on hover off
                    element.setAttribute('visibility', 'hidden');
                }
            };
        }

        // Redraws the stones
        function redrawStones(current) {
            var group = besogo.svgEl("g"), // New stone layer group
                shadowGroup, // Group for shadow layer
                i, j, x, y, color; // Scratch iteration variables

            if (editor.SHADOWS) { // Add group for shawdows
                shadowGroup = besogo.svgShadowGroup();
                group.appendChild(shadowGroup);
            }

            for (i = 1; i <= sizeX; i++) {
                for (j = 1; j <= sizeY; j++) {
                    color = current.getStone(i, j);
                    if (color) {
                        x = svgPos(i);
                        y = svgPos(j);

                        if (editor.REAL_STONES) { // Realistic stone
                            group.appendChild(besogo.realStone(x, y, color, randIndex[fromXY(i, j)]));
                        } else { // SVG stone
                            group.appendChild(besogo.svgStone(x, y, color));
                        }

                        if (editor.SHADOWS) { // Draw shadows
                            shadowGroup.appendChild(besogo.svgShadow(x - 2, y - 4));
                            shadowGroup.appendChild(besogo.svgShadow(x + 2, y + 4));
                        }
                    }
                }
            }

            svg.replaceChild(group, stoneGroup); // Replace the stone group
            stoneGroup = group;
        }

        // Redraws the markup
        function redrawMarkup(current) {
            var element, i, j, x, y, // Scratch iteration variables
                group = besogo.svgEl("g"), // Group holding markup layer elements
                lastMove = current.move,
                variants = editor.getVariants(),
                mark, // Scratch mark state {0, 1, 2, 3, 4, 5}
                stone, // Scratch stone state {0, -1, 1}
                color; // Scratch color string

            markupLayer = []; // Clear the references to the old layer

            for (i = 1; i <= sizeX; i++) {
                for (j = 1; j <= sizeY; j++) {
                    mark = current.getMarkup(i, j);
                    if (mark) {
                        x = svgPos(i);
                        y = svgPos(j);
                        stone = current.getStone(i, j);
                        color = (stone === -1) ? "white" : "black"; // White on black
                        if (lastMove && lastMove.x === i && lastMove.y === j) {
                            // Mark last move blue or violet if also a variant
                            color = checkVariants(variants, current, i, j) ?
                                besogo.PURP : besogo.BLUE;
                        } else if (checkVariants(variants, current, i, j)) {
                            color = besogo.RED; // Natural variant marks are red
                        }
                        if (typeof mark === 'number') { // Markup is a basic shape
                            switch (mark) {
                                case 1:
                                    element = besogo.svgCircle(x, y, color);
                                    break;
                                case 2:
                                    element = besogo.svgSquare(x, y, color);
                                    break;
                                case 3:
                                    element = besogo.svgTriangle(x, y, color);
                                    break;
                                case 4:
                                    element = besogo.svgCross(x, y, color);
                                    break;
                                case 5:
                                    element = besogo.svgBlock(x, y, color);
                                    break;
                            }
                        } else { // Markup is a label
                            if (!stone) { // If placing label on empty spot
                                element = makeBacker(x, y);
                                group.appendChild(element);
                            }
                            element = besogo.svgLabel(x, y, color, mark);
                        }
                        group.appendChild(element);
                        markupLayer[fromXY(i, j)] = element;
                    } // END if (mark)
                } // END for j
            } // END for i

            // Mark last move with plus if not already marked
            if (lastMove && lastMove.x !== 0 && lastMove.y !== 0) {
                i = lastMove.x;
                j = lastMove.y;
                if (!markupLayer[fromXY(i, j)]) { // Last move not marked
                    color = checkVariants(variants, current, i, j) ? besogo.PURP : besogo.BLUE;
                    element = besogo.svgPlus(svgPos(i), svgPos(j), color);
                    group.appendChild(element);
                    markupLayer[fromXY(i, j)] = element;
                }
            }

            // Mark variants that have not already been marked above
            markRemainingVariants(variants, current, group);

            svg.replaceChild(group, markupGroup); // Replace the markup group
            markupGroup = group;
        } // END function redrawMarkup

        function makeBacker(x, y) { // Makes a label markup backer at (x, y)
            return besogo.svgEl("rect", {
                x: x - CELL_SIZE / 2,
                y: y - CELL_SIZE / 2,
                height: CELL_SIZE,
                width: CELL_SIZE,
                opacity: 0.85,
                stroke: "none",
                'class': 'besogo-svg-board'
            });
        }

        // Checks if (x, y) is in variants
        function checkVariants(variants, current, x, y) {
            var i, move;
            for (i = 0; i < variants.length; i++) {
                if (variants[i] !== current) { // Skip current (within siblings)
                    move = variants[i].move;
                    if (move && move.x === x && move.y === y) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Marks variants that have not already been marked
        function markRemainingVariants(variants, current, group) {
            var element,
                move, // Variant move
                label, // Variant label
                stone, // Stone state
                i, x, y; // Scratch iteration variables

            for (i = 0; i < variants.length; i++) {
                if (variants[i] !== current) { // Skip current (within siblings)
                    move = variants[i].move;
                    // Check if move, not a pass, and no mark yet
                    if (move && move.x !== 0 && !markupLayer[fromXY(move.x, move.y)]) {
                        stone = current.getStone(move.x, move.y);
                        x = svgPos(move.x); // Get SVG positions
                        y = svgPos(move.y);
                        if (!stone) { // If placing label on empty spot
                            element = makeBacker(x, y);
                            group.appendChild(element);
                        }
                        // Label variants with letters A-Z cyclically
                        label = String.fromCharCode('A'.charCodeAt(0) + (i % 26));
                        element = besogo.svgLabel(x, y, besogo.LRED, label);
                        group.appendChild(element);
                        markupLayer[fromXY(move.x, move.y)] = element;
                    }
                }
            }
        } // END function markRemainingVariants

        // Redraws the hover layer
        function redrawHover(current) {
            if (TOUCH_FLAG) {
                return; // Do nothing for touch interfaces
            }

            var element, i, j, x, y, // Scratch iteration variables
                group = besogo.svgEl("g"), // Group holding hover layer elements
                tool = editor.getTool(),
                children,
                stone, // Scratch stone state {0, -1, 1} or move
                color; // Scratch color string

            hoverLayer = []; // Clear the references to the old layer
            group.setAttribute('opacity', '0.35');

            if (tool === 'navOnly') { // Render navOnly hover by iterating over children
                children = current.children;
                for (i = 0; i < children.length; i++) {
                    stone = children[i].move;
                    if (stone && stone.x !== 0) { // Child node is move and not a pass
                        x = svgPos(stone.x);
                        y = svgPos(stone.y);
                        element = besogo.svgStone(x, y, stone.color);
                        element.setAttribute('visibility', 'hidden');
                        group.appendChild(element);
                        hoverLayer[fromXY(stone.x, stone.y)] = element;
                    }
                }
            } else { // Render hover for other tools by iterating over grid
                for (i = 1; i <= sizeX; i++) {
                    for (j = 1; j <= sizeY; j++) {
                        element = null;
                        x = svgPos(i);
                        y = svgPos(j);
                        stone = current.getStone(i, j);
                        color = (stone === -1) ? "white" : "black"; // White on black
                        switch (tool) {
                            case 'auto':
                                element = besogo.svgStone(x, y, current.nextToMove);
                                break;
                            case 'playB':
                                element = besogo.svgStone(x, y, -1);
                                break;
                            case 'playW':
                                element = besogo.svgStone(x, y, 1);
                                break;
                            case 'addB':
                                if (stone === -1) {
                                    element = besogo.svgCross(x, y, besogo.RED);
                                } else {
                                    element = besogo.svgEl('g');
                                    element.appendChild(besogo.svgStone(x, y, -1));
                                    element.appendChild(besogo.svgPlus(x, y, besogo.RED));
                                }
                                break;
                            case 'addW':
                                if (stone === 1) {
                                    element = besogo.svgCross(x, y, besogo.RED);
                                } else {
                                    element = besogo.svgEl('g');
                                    element.appendChild(besogo.svgStone(x, y, 1));
                                    element.appendChild(besogo.svgPlus(x, y, besogo.RED));
                                }
                                break;
                            case 'addE':
                                if (stone) {
                                    element = besogo.svgCross(x, y, besogo.RED);
                                }
                                break;
                            case 'clrMark':
                                break; // Nothing
                            case 'circle':
                                element = besogo.svgCircle(x, y, color);
                                break;
                            case 'square':
                                element = besogo.svgSquare(x, y, color);
                                break;
                            case 'triangle':
                                element = besogo.svgTriangle(x, y, color);
                                break;
                            case 'cross':
                                element = besogo.svgCross(x, y, color);
                                break;
                            case 'block':
                                element = besogo.svgBlock(x, y, color);
                                break;
                            case 'label':
                                element = besogo.svgLabel(x, y, color, editor.getLabel());
                                break;
                        } // END switch (tool)
                        if (element) {
                            element.setAttribute('visibility', 'hidden');
                            group.appendChild(element);
                            hoverLayer[fromXY(i, j)] = element;
                        }
                    } // END for j
                } // END for i
            } // END else

            svg.replaceChild(group, hoverGroup); // Replace the hover layer group
            hoverGroup = group;
        } // END function redrawHover

        function svgPos(x) { // Converts (x, y) coordinates to SVG position
            return BOARD_MARGIN + CELL_SIZE / 2 + (x - 1) * CELL_SIZE;
        }

        function fromXY(x, y) { // Converts (x, y) coordinates to linear index
            return (x - 1) * sizeY + (y - 1);
        }
    };besogo.makeCommentPanel = function(container, editor) {
    'use strict';
    var infoTexts = {}, // Holds text nodes for game info properties
        gameInfoTable = document.createElement('table'),
        gameInfoEdit = document.createElement('table'),
        commentBox = document.createElement('div'),
        commentEdit = document.createElement('textarea'),
        playerInfoOrder = 'PW WR WT PB BR BT'.split(' '),
        infoOrder = 'HA KM RU TM OT GN EV PC RO DT RE ON GC AN US SO CP'.split(' '),
        infoIds = {
            PW: 'White Player',
            WR: 'White Rank',
            WT: 'White Team',
            PB: 'Black Player',
            BR: 'Black Rank',
            BT: 'Black Team',

            HA: 'Handicap',
            KM: 'Komi',
            RU: 'Rules',
            TM: 'Timing',
            OT: 'Overtime',

            GN: 'Game Name',
            EV: 'Event',
            PC: 'Place',
            RO: 'Round',
            DT: 'Date',

            RE: 'Result',
            ON: 'Opening',
            GC: 'Comments',

            AN: 'Annotator',
            US: 'Recorder',
            SO: 'Source',
            CP: 'Copyright'
        };

    container.appendChild(makeInfoButton());
    container.appendChild(makeInfoEditButton());
    container.appendChild(makeCommentButton());
    container.appendChild(gameInfoTable);
    container.appendChild(gameInfoEdit);
    infoTexts.C = document.createTextNode('');
    container.appendChild(commentBox);
    commentBox.appendChild(infoTexts.C);
    container.appendChild(commentEdit);

    commentEdit.onblur = function() {
        editor.setComment(commentEdit.value);
    };
    commentEdit.addEventListener('keydown', function(evt) {
        evt = evt || window.event;
        evt.stopPropagation(); // Stop keydown propagation when in focus
    });

    editor.addListener(update);
    update({
        navChange: true,
        gameInfo: editor.getGameInfo()
    });
    gameInfoEdit.style.display = 'none'; // Hide game info editting table initially

    function update(msg) {
        var temp; // Scratch for strings

        if (msg.navChange) {
            temp = editor.getCurrent().comment || '';
            updateText(commentBox, temp, 'C');
            if (editor.getCurrent() === editor.getRoot() &&
                gameInfoTable.firstChild &&
                gameInfoEdit.style.display === 'none') {
                gameInfoTable.style.display = 'table';
            } else {
                gameInfoTable.style.display = 'none';
            }
            commentEdit.style.display = 'none';
            commentBox.style.display = 'block';
        } else if (msg.comment !== undefined) {
            updateText(commentBox, msg.comment, 'C');
            commentEdit.value = msg.comment;
        }

        if (msg.gameInfo) { // Update game info
            updateGameInfoTable(msg.gameInfo);
            updateGameInfoEdit(msg.gameInfo);
        }
    } // END function update

    function updateGameInfoTable(gameInfo) {
        var table = document.createElement('table'),
            i, id, row, cell, text; // Scratch iteration variable

        table.className = 'besogo-gameInfo';
        for (i = 0; i < infoOrder.length; i++) { // Iterate in specified order
            id = infoOrder[i];

            if (gameInfo[id]) { // Only add row if property exists
                row = document.createElement('tr');
                table.appendChild(row);

                cell = document.createElement('td');
                cell.appendChild(document.createTextNode(infoIds[id]));
                row.appendChild(cell);

                cell = document.createElement('td');
                text = document.createTextNode(gameInfo[id]);
                cell.appendChild(text);
                row.appendChild(cell);
            }
        }
        if (!table.firstChild || gameInfoTable.style.display === 'none') {
            table.style.display = 'none'; // Do not display empty table or if already hidden
        }
        container.replaceChild(table, gameInfoTable);
        gameInfoTable = table;
    }

    function updateGameInfoEdit(gameInfo) {
        var table = document.createElement('table'),
            infoTableOrder = playerInfoOrder.concat(infoOrder),
            i, id, row, cell, text;

        table.className = 'besogo-gameInfo';
        for (i = 0; i < infoTableOrder.length; i++) { // Iterate in specified order
            id = infoTableOrder[i];
            row = document.createElement('tr');
            table.appendChild(row);

            cell = document.createElement('td');
            cell.appendChild(document.createTextNode(infoIds[id]));
            row.appendChild(cell);

            cell = document.createElement('td');
            text = document.createElement('input');
            if (gameInfo[id]) {
                text.value = gameInfo[id];
            }
            text.onblur = function(t, id) {
                return function() { // Commit change on blur
                    editor.setGameInfo(t.value, id);
                };
            }(text, id);
            text.addEventListener('keydown', function(evt) {
                evt = evt || window.event;
                evt.stopPropagation(); // Stop keydown propagation when in focus
            });
            cell.appendChild(text);
            row.appendChild(cell);
        }
        if (gameInfoEdit.style.display === 'none') {
            table.style.display = 'none'; // Hide if already hidden
        }
        container.replaceChild(table, gameInfoEdit);
        gameInfoEdit = table;
    }

    function updateText(parent, text, id) {
        var textNode = document.createTextNode(text);
        parent.replaceChild(textNode, infoTexts[id]);
        infoTexts[id] = textNode;
    }

    function makeInfoButton() {
        var button = document.createElement('input');
        button.type = 'button';
        button.value = 'Info';
        button.title = 'Show/hide game info';

        button.onclick = function() {
            if (gameInfoTable.style.display === 'none' && gameInfoTable.firstChild) {
                gameInfoTable.style.display = 'table';
            } else {
                gameInfoTable.style.display = 'none';
            }
            gameInfoEdit.style.display = 'none';
        };
        return button;
    }

    function makeInfoEditButton() {
        var button = document.createElement('input');
        button.type = 'button';
        button.value = 'Edit Info';
        button.title = 'Edit game info';

        button.onclick = function() {
            if (gameInfoEdit.style.display === 'none') {
                gameInfoEdit.style.display = 'table';
            } else {
                gameInfoEdit.style.display = 'none';
            }
            gameInfoTable.style.display = 'none';
        };
        return button;
    }

    function makeCommentButton() {
        var button = document.createElement('input');
        button.type = 'button';
        button.value = 'Comment';
        button.title = 'Edit comment';

        button.onclick = function() {
            if (commentEdit.style.display === 'none') { // Comment edit box hidden
                commentBox.style.display = 'none'; // Hide static comment display
                gameInfoTable.style.display = 'none'; // Hide game info table
                commentEdit.value = editor.getCurrent().comment;
                commentEdit.style.display = 'block'; // Show comment edit box
            } else { // Comment edit box open
                commentEdit.style.display = 'none'; // Hide comment edit box
                commentBox.style.display = 'block'; // Show static comment display
            }
        };
        return button;
    }

};
besogo.makeControlPanel = function(container, editor) {
    'use strict';
    var leftElements = [], // SVG elements for previous node buttons
        rightElements = [], // SVG elements for next node buttons
        siblingElements = [], // SVG elements for sibling buttons
        variantStyleButton, // Button for changing variant style
        hideVariantButton, // Button for toggling show/hide variants
        childVariantElement, // SVG element for child style variants
        siblingVariantElement, // SVG element for sibling style variants
        hideVariantElement; // SVG element for hiding variants

    drawNavButtons();
    drawStyleButtons();

    editor.addListener(update);
    update({
        navChange: true,
        variantStyle: editor.getVariantStyle()
    }); // Initialize

    // Callback for variant style and nav state changes
    function update(msg) {
        var current;

        if (msg.variantStyle !== undefined) {
            updateStyleButtons(msg.variantStyle);
        }

        if (msg.navChange || msg.treeChange) { // Update the navigation buttons
            current = editor.getCurrent();
            if (current.parent) { // Has parent
                arraySetColor(leftElements, 'black');
                if (current.parent.children.length > 1) { // Has siblings
                    arraySetColor(siblingElements, 'black');
                } else { // No siblings
                    arraySetColor(siblingElements, besogo.GREY);
                }
            } else { // No parent
                arraySetColor(leftElements, besogo.GREY);
                arraySetColor(siblingElements, besogo.GREY);
            }
            if (current.children.length) { // Has children
                arraySetColor(rightElements, 'black');
            } else { // No children
                arraySetColor(rightElements, besogo.GREY);
            }
        }

        function updateStyleButtons(style) { // Updates the variant style buttons
            if (style % 2) { // Sibling style variants
                childVariantElement.setAttribute('fill', 'black');
                siblingVariantElement.setAttribute('fill', besogo.BLUE);
                variantStyleButton.title = 'Variants: child/[sibling]';
            } else { // Child style variants
                childVariantElement.setAttribute('fill', besogo.BLUE);
                siblingVariantElement.setAttribute('fill', besogo.RED);
                variantStyleButton.title = 'Variants: [child]/sibling';
            }
            if (style >= 2) { // Hide auto-markup for variants
                hideVariantElement.setAttribute('visibility', 'visible');
                hideVariantButton.title = 'Variants: show/[hide]';
            } else { // Show auto-markup for variants
                hideVariantElement.setAttribute('visibility', 'hidden');
                hideVariantButton.title = 'Variants: [show]/hide';
            }
        }

        function arraySetColor(list, color) { // Changes fill color of list of svg elements
            var i;
            for (i = 0; i < list.length; i++) {
                list[i].setAttribute('fill', color);
            }
        }
    } // END function update

    // Draws the navigation buttons
    function drawNavButtons() {
        leftElements.push(makeNavButton('First node',
            '5,10 5,90 25,90 25,50 95,90 95,10 25,50 25,10',
            function() {
                editor.prevNode(-1);
            }));
        leftElements.push(makeNavButton('Jump back',
            '95,10 50,50 50,10 5,50 50,90 50,50 95,90',
            function() {
                editor.prevNode(10);
            }));
        leftElements.push(makeNavButton('Previous node', '85,10 85,90 15,50', function() {
            editor.prevNode(1);
        }));

        rightElements.push(makeNavButton('Next node', '15,10 15,90 85,50', function() {
            editor.nextNode(1);
        }));
        rightElements.push(makeNavButton('Jump forward',
            '5,10 50,50 50,10 95,50 50,90 50,50 5,90',
            function() {
                editor.nextNode(10);
            }));
        rightElements.push(makeNavButton('Last node',
            '95,10 95,90 75,90 75,50 5,90 5,10 75,50 75,10',
            function() {
                editor.nextNode(-1);
            }));

        siblingElements.push(makeNavButton('Previous sibling', '10,85 90,85 50,15', function() {
            editor.nextSibling(-1);
        }));
        siblingElements.push(makeNavButton('Next sibling', '10,15 90,15 50,85', function() {
            editor.nextSibling(1);
        }));

        function makeNavButton(tooltip, pointString, action) { // Creates a navigation button
            var button = document.createElement('button'),
                svg = makeButtonContainer(),
                element = besogo.svgEl("polygon", {
                    points: pointString,
                    stroke: 'none',
                    fill: 'black'
                });

            button.title = tooltip;
            button.onclick = action;
            button.appendChild(svg);
            svg.appendChild(element);
            container.appendChild(button);

            return element;
        } // END function makeNavButton
    } // END function drawNavButtons

    // Draws the variant style buttons
    function drawStyleButtons() {
        var svg, element, coordStyleButton;

        variantStyleButton = document.createElement('button');
        variantStyleButton.onclick = function() {
            editor.toggleVariantStyle(false); // Toggles child/sibling variants
        };
        container.appendChild(variantStyleButton);
        svg = makeButtonContainer();
        variantStyleButton.appendChild(svg);
        element = besogo.svgEl("path", {
            d: 'm75,25h-50l50,50',
            stroke: 'black',
            "stroke-width": 5,
            fill: 'none'
        });
        svg.appendChild(element);
        childVariantElement = besogo.svgEl('circle', {
            cx: 25,
            cy: 25,
            r: 20,
            stroke: 'none'
        });
        svg.appendChild(childVariantElement);
        siblingVariantElement = besogo.svgEl('circle', {
            cx: 75,
            cy: 25,
            r: 20,
            stroke: 'none'
        });
        svg.appendChild(siblingVariantElement);
        element = besogo.svgEl('circle', {
            cx: 75,
            cy: 75,
            r: 20,
            fill: besogo.RED,
            stroke: 'none'
        });
        svg.appendChild(element);

        hideVariantButton = document.createElement('button');
        hideVariantButton.onclick = function() {
            editor.toggleVariantStyle(true); // Toggles show/hide variants
        };
        container.appendChild(hideVariantButton);
        svg = makeButtonContainer();
        hideVariantButton.appendChild(svg);
        svg.appendChild(besogo.svgLabel(50, 50, besogo.RED, 'A'));
        hideVariantElement = besogo.svgCross(50, 50, 'black');
        svg.appendChild(hideVariantElement);

        coordStyleButton = document.createElement('button');
        coordStyleButton.onclick = function() {
            editor.toggleCoordStyle(); // Toggles coordinate style
        };
        coordStyleButton.title = 'Toggle coordinates';
        container.appendChild(coordStyleButton);
        svg = makeButtonContainer();
        coordStyleButton.appendChild(svg);
        svg.appendChild(besogo.svgLabel(50, 50, 'black', '4'));
    } // END function drawStyleButtons

    // Makes an SVG container for the button graphics
    function makeButtonContainer() {
        return besogo.svgEl('svg', {
            width: '100%',
            height: '100%',
            viewBox: "0 0 100 100"
        });
    }
};
(function() {
    'use strict';

    // Parent object to hold coordinate system helper functions
    besogo.coord = {};

    // Null function for no coordinate system
    besogo.coord.none = function(sizeX, sizeY) {
        return false;
    };

    // Western, chess-like, "A1" coordinate system
    besogo.coord.western = function(sizeX, sizeY) {
        var labels = {
                x: [],
                y: []
            },
            i;
        for (i = 1; i <= sizeX; i++) {
            labels.x[i] = numberToLetter(i);
        }
        for (i = 1; i <= sizeY; i++) {
            labels.y[i] = (sizeY - i + 1) + '';
        }
        return labels;
    };

    // Simple purely numeric coordinate system
    besogo.coord.numeric = function(sizeX, sizeY) {
        var labels = {
                x: [],
                y: []
            },
            i;
        for (i = 1; i <= sizeX; i++) {
            labels.x[i] = i + '';
        }
        for (i = 1; i <= sizeY; i++) {
            labels.y[i] = i + '';
        }
        return labels;
    };

    // Corner-relative, alpha-numeric, coordinate system
    besogo.coord.corner = function(sizeX, sizeY) {
        var labels = {
                x: [],
                y: []
            },
            i;
        for (i = 1; i <= sizeX; i++) {
            if (i < (sizeX / 2) + 1) {
                labels.x[i] = numberToLetter(i);
            } else {
                labels.x[i] = (sizeX - i + 1) + '';
            }
        }
        for (i = 1; i <= sizeY; i++) {
            labels.y[i] = (sizeY - i + 1) + '';
            if (i > (sizeY / 2)) {
                labels.y[i] = numberToLetter(sizeY - i + 1);
            } else {
                labels.y[i] = i + '';
            }
        }
        return labels;
    };

    // Corner-relative, numeric and CJK, coordinate system
    besogo.coord.eastcor = function(sizeX, sizeY) {
        var labels = {
                x: [],
                y: []
            },
            i;
        for (i = 1; i <= sizeX; i++) {
            if (i < (sizeX / 2) + 1) {
                labels.x[i] = numberToCJK(i);
            } else {
                labels.x[i] = (sizeX - i + 1) + '';
            }
        }
        for (i = 1; i <= sizeY; i++) {
            labels.y[i] = (sizeY - i + 1) + '';
            if (i > (sizeY / 2)) {
                labels.y[i] = numberToCJK(sizeY - i + 1);
            } else {
                labels.y[i] = i + '';
            }
        }
        return labels;
    };

    // Eastern, numeric and CJK, coordinate system
    besogo.coord.eastern = function(sizeX, sizeY) {
        var labels = {
                x: [],
                y: []
            },
            i;
        for (i = 1; i <= sizeX; i++) {
            labels.x[i] = i + ''; // Columns are numeric
        }
        for (i = 1; i <= sizeY; i++) {
            labels.y[i] = numberToCJK(i);
        }

        return labels;
    };

    // Helper for converting numeric coord to letter (skipping I)
    function numberToLetter(number) {
        return 'ABCDEFGHJKLMNOPQRSTUVWXYZ'.charAt((number - 1) % 25);
    }

    // Helper for converting numeric coord to CJK symbol
    function numberToCJK(number) {
        var label = '',
            cjk = '';

        if (number >= 20) { // 20 and larger
            label = cjk.charAt(number / 10 - 1) + '';
        } else if (number >= 10) { // 10 through 19
            label = '';
        }
        if (number % 10) { // Ones digit if non-zero
            label = label + cjk.charAt((number - 1) % 10);
        }
        return label;
    }

})(); // END closure
besogo.makeEditor = function(sizeX, sizeY) {
    'use strict';
    // Creates an associated game state tree
    var root = besogo.makeGameRoot(sizeX, sizeY),
        current = root, // Navigation cursor

        listeners = [], // Listeners of general game/editor state changes

        // Enumeration of editor tools/modes
        TOOLS = ['navOnly', // read-only navigate mode
            'auto', // auto-mode: navigate or auto-play color
            'playB', // play black stone
            'playW', // play white stone
            'addB', // setup black stone
            'addW', // setup white stone
            'addE', // setup empty stone
            'clrMark', // remove markup
            'circle', // circle markup
            'square', // square markup
            'triangle', // triangle markup
            'cross', // "X" cross markup
            'block', // filled square markup
            'label'
        ], // label markup
        tool = 'auto', // Currently active tool (default: auto-mode)
        label = "1", // Next label that will be applied

        navHistory = [], // Navigation history

        gameInfo = {}, // Game info properties

        // Order of coordinate systems
        COORDS = 'none numeric western eastern corner eastcor'.split(' '),
        coord = 'none', // Selected coordinate system

        // Variant style: even/odd - children/siblings, <2 - show auto markup for variants
        variantStyle = 0; // 0-3, 0 is default

    return {
        addListener: addListener,
        click: click,
        nextNode: nextNode,
        prevNode: prevNode,
        nextSibling: nextSibling,
        toggleCoordStyle: toggleCoordStyle,
        getCoordStyle: getCoordStyle,
        setCoordStyle: setCoordStyle,
        toggleVariantStyle: toggleVariantStyle,
        getVariantStyle: getVariantStyle,
        setVariantStyle: setVariantStyle,
        getGameInfo: getGameInfo,
        setGameInfo: setGameInfo,
        setComment: setComment,
        getTool: getTool,
        setTool: setTool,
        getLabel: getLabel,
        setLabel: setLabel,
        getVariants: getVariants, // Returns variants of current node
        getCurrent: getCurrent,
        setCurrent: setCurrent,
        cutCurrent: cutCurrent,
        getRoot: getRoot,
        loadRoot: loadRoot // Loads new game state
    };

    // Returns the active tool
    function getTool() {
        return tool;
    }

    // Sets the active tool, returns false if failed
    function setTool(set) {
        // Toggle label mode if already label tool already selected
        if (set === 'label' && set === tool) {
            if (/^-?\d+$/.test(label)) { // If current label is integer
                setLabel('A'); // Toggle to characters
            } else {
                setLabel('1'); // Toggle back to numbers
            }
            return true; // Notification already handled by setLabel
        }
        // Set the tool only if in list and actually changed
        if (TOOLS.indexOf(set) !== -1 && tool !== set) {
            tool = set;
            notifyListeners({
                tool: tool,
                label: label
            }); // Notify tool change
            return true;
        }
        return false;
    }

    // Gets the next label to apply
    function getLabel() {
        return label;
    }

    // Sets the next label to apply and sets active tool to label
    function setLabel(set) {
        if (typeof set === 'string') {
            set = set.replace(/\s/g, ' ').trim(); // Convert all whitespace to space and trim
            label = set || "1"; // Default to "1" if empty string
            tool = 'label'; // Also change current tool to label
            notifyListeners({
                tool: tool,
                label: label
            }); // Notify tool/label change
        }
    }

    // Toggle the coordinate style
    function toggleCoordStyle() {
        coord = COORDS[(COORDS.indexOf(coord) + 1) % COORDS.length];
        notifyListeners({
            coord: coord
        });
    }

    // Gets the current coordinate style
    function getCoordStyle() {
        return coord;
    }

    // Sets the coordinate system style
    function setCoordStyle(setCoord) {
        if (besogo.coord[setCoord]) {
            coord = setCoord;
            notifyListeners({
                coord: setCoord
            });
        }
    }

    // Toggles the style for showing variants
    function toggleVariantStyle(toggleShow) {
        var childStyle = variantStyle % 2, // 0: children, 1: siblings
            showStyle = variantStyle - childStyle; // 0: show auto-markup, 2: hide
        if (toggleShow) { // Truthy input toggles showing of auto-markup
            showStyle = (showStyle + 2) % 4; // 0 => 2 or 2 => 0
        } else { // Falsy input toggles child vs sibling style
            childStyle = (childStyle + 1) % 2; // 0 => 1 or 1 => 0
        }
        variantStyle = childStyle + showStyle;
        notifyListeners({
            variantStyle: variantStyle,
            markupChange: true
        });
    }

    // Returns the variant style
    function getVariantStyle() {
        return variantStyle;
    }

    // Directly sets the variant style
    function setVariantStyle(style) {
        if (style === 0 || style === 1 || style === 2 || style === 3) {
            variantStyle = style;
            notifyListeners({
                variantStyle: variantStyle,
                markupChange: true
            });
        }
    }

    function getGameInfo() {
        return gameInfo;
    }

    function setGameInfo(info, id) {
        if (id) {
            gameInfo[id] = info;
        } else {
            gameInfo = info;
        }
        notifyListeners({
            gameInfo: gameInfo
        });
    }

    function setComment(text) {
        text = text.trim(); // Trim whitespace and standardize line breaks
        text = text.replace(/\r\n/g, '\n').replace(/\n\r/g, '\n').replace(/\r/g, '\n');
        text.replace(/\f\t\v\u0085\u00a0/g, ' '); // Convert other whitespace to space
        current.comment = text;
        notifyListeners({
            comment: text
        });
    }

    // Returns variants of the current node according to the set style
    function getVariants() {
        if (variantStyle >= 2) { // Do not show variants if style >= 2
            return [];
        }
        if (variantStyle === 1) { // Display sibling variants
            // Root node does not have parent nor siblings
            return current.parent ? current.parent.children : [];
        }
        return current.children; // Otherwise, style must be 0, display child variants
    }

    // Returns the currently active node in the game state tree
    function getCurrent() {
        return current;
    }

    // Returns the root of the game state tree
    function getRoot() {
        return root;
    }

    function loadRoot(load) {
        root = load;
        current = load;
        notifyListeners({
            treeChange: true,
            navChange: true,
            stoneChange: true
        });
    }

    // Navigates forward num nodes (to the end if num === -1)
    function nextNode(num) {
        if (current.children.length === 0) { // Check if no children
            return false; // Do nothing if no children (avoid notification)
        }
        while (current.children.length > 0 && num !== 0) {
            if (navHistory.length) { // Non-empty navigation history
                current = navHistory.pop();
            } else { // Empty navigation history
                current = current.children[0]; // Go to first child
            }
            num--;
        }
        // Notify listeners of navigation (with no tree edits)
        notifyListeners({
            navChange: true
        }, true); // Preserve history
    }

    // Navigates backward num nodes (to the root if num === -1)
    function prevNode(num) {
        if (current.parent === null) { // Check if root
            return false; // Do nothing if already at root (avoid notification)
        }
        while (current.parent && num !== 0) {
            navHistory.push(current); // Save current into navigation history
            current = current.parent;
            num--;
        }
        // Notify listeners of navigation (with no tree edits)
        notifyListeners({
            navChange: true
        }, true); // Preserve history
    }

    // Cyclically switches through siblings
    function nextSibling(change) {
        var siblings,
            i = 0;

        if (current.parent) {
            siblings = current.parent.children;

            // Exit early if only child
            if (siblings.length === 1) {
                return;
            }

            // Find index of current amongst siblings
            i = siblings.indexOf(current);

            // Apply change cyclically
            i = (i + change) % siblings.length;
            if (i < 0) {
                i += siblings.length;
            }

            current = siblings[i];
            // Notify listeners of navigation (with no tree edits)
            notifyListeners({
                navChange: true
            });
        }
    }

    // Sets the current node
    function setCurrent(node) {
        if (current !== node) {
            current = node;
            // Notify listeners of navigation (with no tree edits)
            notifyListeners({
                navChange: true
            });
        }
    }

    // Removes current branch from the tree
    function cutCurrent() {
        var parent = current.parent;
        if (tool === 'navOnly') {
            return; // Tree editing disabled in navOnly mode
        }
        if (parent) {
            if (confirm("Delete this branch?") === true) {
                parent.removeChild(current);
                current = parent;
                // Notify navigation and tree edited
                notifyListeners({
                    treeChange: true,
                    navChange: true
                });
            }
        }
    }

    // Handle click with application of selected tool
    function click(i, j, ctrlKey, shiftKey) {
        switch (tool) {
            case 'navOnly':
                navigate(i, j, shiftKey);
                break;
            case 'auto':
                if (!navigate(i, j, shiftKey) && !shiftKey) { // Try to navigate to (i, j)
                    playMove(i, j, 0, ctrlKey); // Play auto-color move if navigate fails
                }
                break;
            case 'playB':
                playMove(i, j, -1, ctrlKey); // Black move
                break;
            case 'playW':
                playMove(i, j, 1, ctrlKey); // White move
                break;
            case 'addB':
                placeSetup(i, j, -1);
                break;
            case 'addW':
                placeSetup(i, j, 1);
                break;
            case 'addE':
                placeSetup(i, j, 0);
                break;
            case 'clrMark':
                setMarkup(i, j, 0);
                break;
            case 'circle':
                setMarkup(i, j, 1);
                break;
            case 'square':
                setMarkup(i, j, 2);
                break;
            case 'triangle':
                setMarkup(i, j, 3);
                break;
            case 'cross':
                setMarkup(i, j, 4);
                break;
            case 'block':
                setMarkup(i, j, 5);
                break;
            case 'label':
                setMarkup(i, j, label);
                break;
        }
    }

    // Navigates to child with move at (x, y), searching tree if shiftKey pressed
    // Returns true is successful, false if not
    function navigate(x, y, shiftKey) {
        var i, move,
            children = current.children;

        // Look for move at same location in children
        for (i = 0; i < children.length; i++) {
            move = children[i].move;
            if (move && move.x === x && move.y === y) {
                current = children[i]; // Navigate to child if found
                // Notify navigation (with no tree edits)
                notifyListeners({
                    navChange: true
                });
                return true;
            }
        }
        return false;
    }

    // Plays a move at the given color and location
    // Set allowAll to truthy to allow illegal moves
    function playMove(i, j, color, allowAll) {
        var next;
        // Check if current node is immutable or root
        if (!current.isMutable('move') || !current.parent) {
            next = current.makeChild(); // Create a new child node
            if (next.playMove(i, j, color, allowAll)) { // Play in new node
                // Keep (add to game state tree) only if move succeeds
                current.addChild(next);
                current = next;
                // Notify tree change, navigation, and stone change
                notifyListeners({
                    treeChange: true,
                    navChange: true,
                    stoneChange: true
                });
            }
            // Current node is mutable and not root
        } else if (current.playMove(i, j, color, allowAll)) { // Play in current
            // Only need to update if move succeeds
            notifyListeners({
                stoneChange: true
            }); // Stones changed
        }
    }

    // Places a setup stone at the given color and location
    function placeSetup(i, j, color) {
        var next;
        if (color === current.getStone(i, j)) { // Compare setup to current
            if (color !== 0) {
                color = 0; // Same as current indicates removal desired
            } else { // Color and current are both empty
                return; // No change if attempting to set empty to empty
            }
        }
        // Check if current node can accept setup stones
        if (!current.isMutable('setup')) {
            next = current.makeChild(); // Create a new child node
            if (next.placeSetup(i, j, color)) { // Place setup stone in new node
                // Keep (add to game state tree) only if change occurs
                current.addChild(next);
                current = next;
                // Notify tree change, navigation, and stone change
                notifyListeners({
                    treeChange: true,
                    navChange: true,
                    stoneChange: true
                });
            }
        } else if (current.placeSetup(i, j, color)) { // Try setup in current
            // Only need to update if change occurs
            notifyListeners({
                stoneChange: true
            }); // Stones changed
        }
    }

    // Sets the markup at the given location and place
    function setMarkup(i, j, mark) {
        var temp; // For label incrementing
        if (mark === current.getMarkup(i, j)) { // Compare mark to current
            if (mark !== 0) {
                mark = 0; // Same as current indicates removal desired
            } else { // Mark and current are both empty
                return; // No change if attempting to set empty to empty
            }
        }
        if (current.addMarkup(i, j, mark)) { // Try to add the markup
            if (typeof mark === 'string') { // If markup is a label, increment the label
                if (/^-?\d+$/.test(mark)) { // Integer number label
                    temp = +mark; // Convert to number
                    // Increment and convert back to string
                    setLabel("" + (temp + 1));
                } else if (/[A-Za-z]$/.test(mark)) { // Ends with [A-Za-z]
                    // Get the last character in the label
                    temp = mark.charAt(mark.length - 1);
                    if (temp === 'z') { // Cyclical increment
                        temp = 'A'; // Move onto uppercase letters
                    } else if (temp === 'Z') {
                        temp = 'a'; // Move onto lowercase letters
                    } else {
                        temp = String.fromCharCode(temp.charCodeAt() + 1);
                    }
                    // Replace last character of label with incremented char
                    setLabel(mark.slice(0, mark.length - 1) + temp);
                }
            }
            notifyListeners({
                markupChange: true
            }); // Notify markup change
        }
    }

    // Adds a listener (by call back func) that will be notified on game/editor state changes
    function addListener(listener) {
        listeners.push(listener);
    }

    // Notify listeners with the given message object
    //  Data sent to listeners:
    //    tool: changed tool selection
    //    label: changed next label
    //    coord: changed coordinate system 
    //    variantStyle: changed variant style
    //    gameInfo: changed game info
    //    comment: changed comment in current node
    //  Flags sent to listeners:
    //    treeChange: nodes added or removed from tree
    //    navChange: current switched to different node
    //    stoneChange: stones modified in current node
    //    markupChange: markup modified in current node
    function notifyListeners(msg, keepHistory) {
        var i;
        if (!keepHistory && msg.navChange) {
            navHistory = []; // Clear navigation history
        }
        for (i = 0; i < listeners.length; i++) {
            listeners[i](msg);
        }
    }
};
besogo.makeFilePanel = function(container, editor) {
    'use strict';
    var fileChooser, // Reference to the file chooser element
        element, // Scratch variable for creating elements
        WARNING = "Everything not saved will be lost";

    makeNewBoardButton(9); // New 9x9 board button
    makeNewBoardButton(13); // New 13x13 board button
    makeNewBoardButton(19); // New 19x19 board button
    makeNewBoardButton('?'); // New custom board button

    // Hidden file chooser element
    fileChooser = makeFileChooser();
    container.appendChild(fileChooser);

    // Load file button
    element = document.createElement('input');
    element.type = 'button';
    element.value = 'Open';
    element.title = 'Import SGF';
    element.onclick = function() { // Bind click to the hidden file chooser
        fileChooser.click();
    };
    container.appendChild(element);

    // Save file button
    element = document.createElement('input');
    element.type = 'button';
    element.value = 'Save';
    element.title = 'Export SGF';
    element.onclick = function() {
        var fileName = prompt('Save file as', 'export.sgf');
        if (fileName) { // Canceled or empty string does nothing
            saveFile(fileName, besogo.composeSgf(editor));
        }
    };
    container.appendChild(element);

    // Makes a new board button
    function makeNewBoardButton(size) {
        var button = document.createElement('input');
        button.type = 'button';
        button.value = size + "x" + size;
        if (size === '?') { // Make button for custom sized board
            button.title = "New custom size board";
            button.onclick = function() {
                var input = prompt("Enter custom size for new board" + "\n" + WARNING, "19:19"),
                    size;
                if (input) { // Canceled or empty string does nothing
                    size = besogo.parseSize(input);
                    editor.loadRoot(besogo.makeGameRoot(size.x, size.y));
                    editor.setGameInfo({});
                }
            };
        } else { // Make button for fixed size board
            button.title = "New " + size + "x" + size + " board";
            button.onclick = function() {
                if (confirm(button.title + "?\n" + WARNING)) {
                    editor.loadRoot(besogo.makeGameRoot(size, size));
                    editor.setGameInfo({});
                }
            };
        }
        container.appendChild(button);
    }

    // Creates the file selector
    function makeFileChooser() {
        var chooser = document.createElement('input');
        chooser.type = 'file';
        chooser.style.display = 'none'; // Keep hidden
        chooser.onchange = readFile; // Read, parse and load on file select
        return chooser;
    }

    // Reads, parses and loads an SGF file
    function readFile(evt) {
        var file = evt.target.files[0], // Selected file
            reader = new FileReader(),
            newChooser = makeFileChooser(); // Create new file input to reset selection

        container.replaceChild(newChooser, fileChooser); // Replace with the reset selector
        fileChooser = newChooser;

        reader.onload = function(e) { // Parse and load game tree
            var sgf;
            try {
                sgf = besogo.parseSgf(e.target.result);
            } catch (error) {
                alert('SGF parse error at ' + error.at + ':\n' + error.message);
                return;
            }
            besogo.loadSgf(sgf, editor);
        };
        if (confirm("Load '" + file.name + "'?\n" + WARNING)) {
            reader.readAsText(file); // Initiate file read
        }
    }

    // Composes SGF file and initializes download
    function saveFile(fileName, text) {
        var link = document.createElement('a'),
            blob = new Blob([text], {
                encoding: "UTF-8",
                type: "text/plain;charset=UTF-8"
            });

        link.download = fileName; // Set download file name
        link.href = URL.createObjectURL(blob);
        link.style.display = 'none'; // Make link hidden
        container.appendChild(link); // Add link to ensure that clicking works
        link.click(); // Click on link to initiate download
        container.removeChild(link); // Immediately remove the link
    }
};
besogo.makeGameRoot = function(sizeX, sizeY) {
    'use strict';
    var BLACK = -1, // Stone state constants
        WHITE = 1, // Equal to -BLACK
        EMPTY = 0, // Any falsy (e.g., undefined) value is also empty

        root = { // Inherited attributes of root node
            nextToMove: BLACK,
            blackCaps: 0,
            whiteCaps: 0,
            moveNumber: 0
        };

    // Initializes non-inherited attributes
    function initNode(node, parent) {
        node.parent = parent;
        node.children = [];

        node.move = null;
        node.setupStones = [];
        node.markup = [];
        node.comment = ''; // Comment on this node
    }
    initNode(root, null); // Initialize root node with null parent

    // Plays a move, returns true if successful
    // Set allow to truthy to allow overwrite, suicide and ko
    root.playMove = function(x, y, color, allow) {
        var captures = 0, // Number of captures made by this move
            overwrite = false, // Flags whether move overwrites a stone
            prevMove, // Previous move for ko check
            testBoard, // Copy of board state to test captures, ko, and suicide
            pending, // Pending capture locations
            i; // Scratch iteration variable

        if (!this.isMutable('move')) {
            return false; // Move fails if node is immutable
        }

        if (!color) { // Falsy color indicates auto-color
            color = this.nextToMove;
        }

        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {
            this.move = { // Register as pass move if out of bounds
                x: 0,
                y: 0, // Log pass as position (0, 0)
                color: color,
                captures: 0, // Pass never captures
                overwrite: false // Pass is never an overwrite
            };
            this.nextToMove = -color; // Update next to move
            this.moveNumber++; // Increment move number
            return true; // Pass move successful
        }

        if (this.getStone(x, y)) { // Check for overwrite
            if (!allow) {
                return false; // Reject overwrite move if not allowed
            }
            overwrite = true; // Otherwise, flag overwrite and proceed
        }

        testBoard = Object.create(this); // Copy board state (no need to initialize)
        pending = []; // Initialize pending capture array

        setStone(testBoard, x, y, color); // Place the move stone

        // Check for captures of surrounding chains
        captureStones(testBoard, x - 1, y, color, pending);
        captureStones(testBoard, x + 1, y, color, pending);
        captureStones(testBoard, x, y - 1, color, pending);
        captureStones(testBoard, x, y + 1, color, pending);

        captures = pending.length; // Capture count

        prevMove = this.parent ? this.parent.move : null; // Previous move played
        if (!allow && prevMove && // If previous move exists, ...
            prevMove.color === -color && // was of the opposite color, ...
            prevMove.overwrite === false && // not an overwrite, ...
            prevMove.captures === 1 && // captured exactly one stone, and if ...
            captures === 1 && // this move captured exactly one stone at the location ...
            !testBoard.getStone(prevMove.x, prevMove.y)) { // of the previous move
            return false; // Reject ko move if not allowed
        }

        if (captures === 0) { // Check for suicide if nothing was captured
            captureStones(testBoard, x, y, -color, pending); // Invert color for suicide check
            captures = -pending.length; // Count suicide as negative captures
            if (captures < 0 && !allow) {
                return false; // Reject suicidal move if not allowed
            }
        }

        if (color * captures < 0) { // Capture by black or suicide by white
            this.blackCaps += Math.abs(captures); // Tally captures for black
        } else { // Capture by white or suicide by black
            this.whiteCaps += Math.abs(captures); // Tally captures for white
        }

        setStone(this, x, y, color); // Place the stone
        for (i = 0; i < pending.length; i++) { // Remove the captures
            setStone(this, pending[i].x, pending[i].y, EMPTY);
        }

        this.move = { // Log the move
            x: x,
            y: y,
            color: color,
            captures: captures,
            overwrite: overwrite
        };
        this.nextToMove = -color; // Update next to move
        this.moveNumber++; // Increment move number
        return true;
    }; // END func root.playMove

    // Check for and perform capture of opposite color chain at (x, y)
    function captureStones(board, x, y, color, captures) {
        var pending = [],
            i; // Scratch iteration variable

        if (!recursiveCapture(board, x, y, color, pending)) { // Captured chain found
            for (i = 0; i < pending.length; i++) { // Remove captured stones
                setStone(board, pending[i].x, pending[i].y, EMPTY);
                captures.push(pending[i]);
            }
        }
    }

    // Recursively builds a chain of pending captures starting from (x, y)
    // Stops and returns true if chain has liberties
    function recursiveCapture(board, x, y, color, pending) {
        var i; // Scratch iteration variable

        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {
            return false; // Stop if out of bounds
        }
        if (board.getStone(x, y) === color) {
            return false; // Stop if other color found
        }
        if (!board.getStone(x, y)) {
            return true; // Stop and signal that liberty was found
        }
        for (i = 0; i < pending.length; i++) {
            if (pending[i].x === x && pending[i].y === y) {
                return false; // Stop if already in pending captures
            }
        }

        pending.push({
            x: x,
            y: y
        }); // Add new stone into chain of pending captures

        // Recursively check for liberties and expand chain
        if (recursiveCapture(board, x - 1, y, color, pending) ||
            recursiveCapture(board, x + 1, y, color, pending) ||
            recursiveCapture(board, x, y - 1, color, pending) ||
            recursiveCapture(board, x, y + 1, color, pending)) {
            return true; // Stop and signal liberty found in subchain
        }
        return false; // Otherwise, no liberties found
    }

    // Places a setup stone, returns true if successful
    root.placeSetup = function(x, y, color) {
        var prevColor = (this.parent && this.parent.getStone(x, y)) || EMPTY;

        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {
            return false; // Do not allow out of bounds setup
        }
        if (!this.isMutable('setup') || this.getStone(x, y) === color) {
            // Prevent setup changes in immutable node or quit early if no change
            return false;
        }

        setStone(this, x, y, color); // Place the setup stone
        this.setupStones[fromXY(x, y)] = color - prevColor; // Record the necessary change
        return true;
    };

    // Adds markup, returns true if successful
    root.addMarkup = function(x, y, mark) {
        if (x < 1 || y < 1 || x > sizeX || y > sizeY) {
            return false; // Do not allow out of bounds markup
        }
        if (this.getMarkup(x, y) === mark) { // Quit early if no change to make
            return false;
        }
        this.markup[fromXY(x, y)] = mark;
        return true;
    };

    // Returns the stone status of the given position
    root.getStone = function(x, y) {
        return this['board' + x + '-' + y] || EMPTY;
    };

    // Directly sets the stone state for the given game node
    function setStone(node, x, y, color) {
        node['board' + x + '-' + y] = color;
    }

    // Gets the setup stone placed at (x, y), returns false if none
    root.getSetup = function(x, y) {
        if (!this.setupStones[fromXY(x, y)]) { // No setup stone placed
            return false;
        } else { // Determine net effect of setup stone
            switch (this.getStone(x, y)) {
                case EMPTY:
                    return 'AE';
                case BLACK:
                    return 'AB';
                case WHITE:
                    return 'AW';
            }
        }
    };

    // Gets the markup at (x, y)
    root.getMarkup = function(x, y) {
        return this.markup[fromXY(x, y)] || EMPTY;
    };

    // Determines the type of this node
    root.getType = function() {
        var i;

        if (this.move) { // Logged move implies move node
            return 'move';
        }

        for (i = 0; i < this.setupStones.length; i++) {
            if (this.setupStones[i]) { // Any setup stones implies setup node
                return 'setup';
            }
        }

        return 'empty'; // Otherwise, "empty" (neither move nor setup)
    };

    // Checks if this node can be modified by a 'type' action
    root.isMutable = function(type) {
        // Can only add a move to an empty node with no children
        if (type === 'move' && this.getType() === 'empty' && this.children.length === 0) {
            return true;
        }
        // Can only add setup stones to a non-move node with no children
        if (type === 'setup' && this.getType() !== 'move' && this.children.length === 0) {
            return true;
        }
        return false;
    };

    // Gets siblings of this node
    root.getSiblings = function() {
        return (this.parent && this.parent.children) || [];
    };

    // Makes a child node of this node, but does NOT add it to children
    root.makeChild = function() {
        var child = Object.create(this); // Child inherits properties
        initNode(child, this); // Initialize other properties

        return child;
    };

    // Adds a child to this node
    root.addChild = function(child) {
        this.children.push(child);
    };

    // Remove child node from this node, returning false if failed
    root.removeChild = function(child) {
        var i = this.children.indexOf(child);
        if (i !== -1) {
            this.children.splice(i, 1);
            return true;
        }
        return false;
    };

    // Gets board size
    root.getSize = function() {
        return {
            x: sizeX,
            y: sizeY
        };
    };

    return root;

    // Convert (x, y) coordinates to linear index
    function fromXY(x, y) {
        return (x - 1) * sizeY + (y - 1);
    }
};
// Load a parsed SGF object into a game state tree
besogo.loadSgf = function(sgf, editor) {
    'use strict';
    var size = {
            x: 19,
            y: 19
        }, // Default size (may be changed by load)
        firstMoveBlank = true,
        root;

    loadRootProps(sgf); // Load size, variants style and game info
    root = besogo.makeGameRoot(size.x, size.y);

    loadNodeTree(sgf, root); // Load the rest of game tree
    editor.loadRoot(root); // Load root into the editor

    // Loads the game tree
    function loadNodeTree(sgfNode, gameNode) {
        var i, nextGameNode;

        // Load properties from the SGF node into the game state node
        for (i = 0; i < sgfNode.props.length; i++) {
            loadProp(gameNode, sgfNode.props[i]);
        }

        // Recursively load the rest of the tree
        for (i = 0; i < sgfNode.children.length; i++) {
            nextGameNode = gameNode.makeChild();
            gameNode.addChild(nextGameNode);
            loadNodeTree(sgfNode.children[i], nextGameNode);
        }
    }

    // Loads property into node
    function loadProp(node, prop) {
        var setupFunc = 'placeSetup',
            markupFunc = 'addMarkup',
            whiteStone = 1,
            blackStone = -1,
            move;
        
        if (probVar & 8) {  // Swap black and white stones on the board
            whiteStone = -1;
            blackStone = 1;
        };

        switch (prop.id) {
            case 'B': // Play a black move
                move = lettersToCoords(prop.values[0]);
                node.playMove(move.x, move.y, blackStone, true);
                if (firstMoveBlank) {
                    firstMoveBlank = false;
                    root.nextToMove = blackStone;
                };
                break;
            case 'W': // Play a white move
                move = lettersToCoords(prop.values[0]);
                node.playMove(move.x, move.y, whiteStone, true);
                if (firstMoveBlank) {
                    firstMoveBlank = false;
                    root.nextToMove = whiteStone;
                };
                break;
            case 'AB': // Setup black stones
                applyPointList(prop.values, node, setupFunc, blackStone);
                break;
            case 'AW': // Setup white stones
                applyPointList(prop.values, node, setupFunc, whiteStone);
                break;
            case 'AE': // Setup empty stones
                applyPointList(prop.values, node, setupFunc, 0);
                break;
            case 'CR': // Add circle markup
                applyPointList(prop.values, node, markupFunc, 1);
                break;
            case 'SQ': // Add square markup
                applyPointList(prop.values, node, markupFunc, 2);
                break;
            case 'TR': // Add triangle markup
                applyPointList(prop.values, node, markupFunc, 3);
                break;
            case 'M': // Intentional fallthrough treats 'M' as 'MA'
            case 'MA': // Add 'X' cross markup
                applyPointList(prop.values, node, markupFunc, 4);
                break;
            case 'SL': // Add 'selected' (small filled square) markup
                applyPointList(prop.values, node, markupFunc, 5);
                break;
            case 'L': // Intentional fallthrough treats 'L' as 'LB'
            case 'LB': // Add label markup
                applyPointList(prop.values, node, markupFunc, 'label');
                break;
            case 'C': // Comment placed on node
                if (node.comment) {
                    node.comment += '\n' + prop.values.join().trim();
                } else {
                    node.comment = prop.values.join().trim();
                }
                if (probVar & 8) {   // Swap 'Black' and 'White' in the comments
                    node.comment = node.comment.replace(/White/g, "BBBBB");
                    node.comment = node.comment.replace(/Black/g, "White");
                    node.comment = node.comment.replace(/BBBBB/g, "Black");
                };
                break;
        }
    } // END function loadProp

    // Extracts point list and calls func on each
    // Set param to 'label' to signal handling of label markup property
    function applyPointList(values, node, func, param) {
        var i, x, y, // Scratch iteration variables
            point, // Current point in iteration
            otherPoint, // Bottom-right point of compressed point lists
            label; // Label extracted from value
        for (i = 0; i < values.length; i++) {
            point = lettersToCoords(values[i].slice(0, 2));
            if (param === 'label') { // Label markup property
                label = values[i].slice(3).replace(/\n/g, ' ');
                node[func](point.x, point.y, label); // Apply with extracted label
            } else { // Not a label markup property
                if (values[i].charAt(2) === ':') { // Expand compressed point list
                    otherPoint = lettersToCoords(values[i].slice(3));
                    if (otherPoint.x === point.x && otherPoint.y === point.y) {
                        // Redundant compressed pointlist
                        node[func](point.x, point.y, param);
                    } else if (otherPoint.x < point.x || otherPoint.y < point.y) {
                        // Only apply to corners if not arranged properly
                        node[func](point.x, point.y, param);
                        node[func](otherPoint.x, otherPoint.y, param);
                    } else { // Iterate over the compressed points
                        for (x = point.x; x <= otherPoint.x; x++) {
                            for (y = point.y; y <= otherPoint.y; y++) {
                                node[func](x, y, param);
                            }
                        }
                    }
                } else { // Apply on single point
                    node[func](point.x, point.y, param);
                }
            }
        }
    } // END function applyPointList

    // Loads root properties (size, variant style and game info)
    function loadRootProps(node) {
        var gameInfoIds = ['PB', 'BR', 'BT', 'PW', 'WR', 'WT', // Player info
                'HA', 'KM', 'RU', 'TM', 'OT', // Game parameters
                'DT', 'EV', 'GN', 'PC', 'RO', // Event info
                'GC', 'ON', 'RE', // General comments
                'AN', 'CP', 'SO', 'US'
            ], // IP credits
            gameInfo = {}, // Structure for game info properties
            i, id, value; // Scratch iteration variables

        for (i = 0; i < node.props.length; i++) {
            id = node.props[i].id; // Property ID
            value = node.props[i].values.join().trim(); // Join the values array
            if (id === 'SZ') { // Size property
                size = besogo.parseSize(value);
                if (probVar & 4) { // Swap dimensions if diagonal flip
                    var temp = size.x;
                    size.x = size.y;
                    size.y = temp;
                }
            } else if (id === 'ST') { // Style property
                editor.setVariantStyle(+value); // Converts value to number
            } else if (gameInfoIds.indexOf(id) !== -1) { // Game info property
                if (id !== 'GC') { // Treat all but GC as simpletext
                    value = value.replace(/\n/g, ' '); // Convert line breaks to spaces
                }
                if (value) { // Skip load of empty game info strings
                    gameInfo[id] = value;
                }
            }
        }
        editor.setGameInfo(gameInfo);
    }

    // Converts letters to numerical coordinates
    function lettersToCoords(letters) {
        if (letters.match(/^[A-Za-z]{2}$/)) { // Verify input is two letters
            let result = {
                x: charToNum(letters.charAt(0)),
                y: charToNum(letters.charAt(1))
            };
            
            // Determine dimensions for flipping
            // If probVar & 4, size is swapped relative to the coordinate space of result (pre-swap)
            let width = (probVar & 4) ? size.y : size.x;
            let height = (probVar & 4) ? size.x : size.y;

            if (probVar & 1) { result.x = width + 1 - result.x };  // Flip horizontally
            if (probVar & 2) { result.y = height + 1 - result.y };  // Flip vertically
            if (probVar & 4) {                                      // Flip diagonally
                let temp = result.x;
                result.x = result.y;
                result.y = temp;
            };
            return result;
        } else { // Anything but two letters
            return {
                x: 0,
                y: 0
            }; // Return (0, 0) coordinates
        }
    }

    function charToNum(c) { // Helper for lettersToCoords
        if (c.match(/[A-Z]/)) { // Letters A-Z to 27-52
            return c.charCodeAt(0) - 'A'.charCodeAt(0) + 27;
        } else { // Letters a-z to 1-26
            return c.charCodeAt(0) - 'a'.charCodeAt(0) + 1;
        }
    }
};
besogo.makeNamesPanel = function(container, editor) {
    'use strict';
    var playerBox = document.createElement('div'),
        whiteBox = document.createElement('div'),
        blackBox = document.createElement('div'),
        whiteInfo = document.createTextNode(''),
        blackInfo = document.createTextNode(''),
        whiteCaps = document.createElement('span'),
        blackCaps = document.createElement('span');

    playerBox.className = 'besogo-playerInfo';
    whiteBox.className = 'besogo-whiteInfo';
    blackBox.className = 'besogo-blackInfo';
    whiteCaps.className = 'besogo-whiteCaps';
    whiteCaps.title = 'White captures';
    blackCaps.className = 'besogo-blackCaps';
    blackCaps.title = 'Black captures';
    whiteBox.appendChild(whiteInfo);
    whiteBox.appendChild(whiteCaps);
    blackBox.appendChild(blackInfo);
    blackBox.appendChild(blackCaps);
    playerBox.appendChild(whiteBox);
    playerBox.appendChild(blackBox);
    container.appendChild(playerBox);

    editor.addListener(update);
    update({
        navChange: true,
        gameInfo: editor.getGameInfo()
    });

    function update(msg) {
        var infoString, // Scratch string
            textNode,
            current,
            passFlag = 0;

        if (msg.gameInfo) {
            infoString = (msg.gameInfo.PW || 'White') + // White name
                ' (' + (msg.gameInfo.WR || '?') + ')' + // White rank
                (msg.gameInfo.WT ? ' ' + msg.gameInfo.WT : ''); // White team
            textNode = document.createTextNode(infoString);
            whiteBox.replaceChild(textNode, whiteInfo);
            whiteInfo = textNode;

            infoString = (msg.gameInfo.PB || 'Black') + // Black name
                ' (' + (msg.gameInfo.BR || '?') + ')' + // Black rank
                (msg.gameInfo.BT ? ' ' + msg.gameInfo.BT : ''); // Black team
            textNode = document.createTextNode(infoString);
            blackBox.replaceChild(textNode, blackInfo);
            blackInfo = textNode;
        }

        if (msg.navChange || msg.stoneChange) {
            current = editor.getCurrent();
            if (current.move && current.move.x === 0 && current.move.y === 0) {
                passFlag = current.move.color;
            }
            updateText(whiteCaps, (passFlag === 1 ? 'Passed  ' : '') + current.whiteCaps);
            updateText(blackCaps, current.blackCaps + (passFlag === -1 ? '  Passed' : ''));
        }
    }

    function updateText(parent, text) {
        var textNode = document.createTextNode(text);
        while (parent.firstChild) {
            parent.removeChild(parent.firstChild);
        }
        parent.appendChild(textNode);
    }
};
besogo.parseSgf = function(text) {
    'use strict';
    var at = 0, // Current position
        ch = text.charAt(at); // Current character at position

    findOpenParens(); // Find beginning of game tree
    return parseTree(); // Parse game tree

    // Builds and throws an error
    function error(msg) {
        throw {
            name: "Syntax Error",
            message: msg,
            at: at,
            text: text
        };
    }

    // Advances text position by one
    function next(check) {
        if (check && check !== ch) { // Verify current character if param given
            error("Expected '" + check + "' instead of '" + ch + "'");
        }
        at++;
        ch = text.charAt(at);
        return ch;
    }

    // Skips over whitespace until non-whitespace found
    function white() {
        while (ch && ch <= ' ') {
            next();
        }
    }

    // Skips all chars until '(' or end found
    function findOpenParens() {
        while (ch && ch !== '(') {
            next();
        }
    }

    // Returns true if line break (CR, LF, CR+LF, LF+CR) found
    // Advances the cursor ONCE for double character (CR+LF, LF+CR) line breaks
    function lineBreak() {
        if (ch === '\n') { // Line Feed (LF)
            if (text.charAt(at + 1) === '\r') { // LF+CR, double character line break
                next(); // Advance cursor only once (pointing at second character)
            }
            return true;
        } else if (ch === '\r') { // Carriage Return (CR)
            if (text.charAt(at + 1) === '\n') { // CR+LF, double character line break
                next(); // Advance cursor only once (pointing at second character)
            }
            return true;
        }
        return false; // Did not find a line break or advance
    }

    // Parses a sub-tree of the game record
    function parseTree() {
        var rootNode, // Root of this sub-tree
            currentNode, // Pointer to parent of the next node
            nextNode; // Scratch for parsing the next node or sub-tree

        next('('); // Double-check opening parens at start of sub-tree
        white(); // Skip whitespace before root node

        if (ch !== ";") { // Error on sub-tree missing root node
            error("Sub-tree missing root");
        }
        rootNode = parseNode(); // Get the first node of this sub-tree
        white(); // Skip whitespace before parsing next node

        currentNode = rootNode; // Parent of the next node parsed
        while (ch === ';') { // Get sequence of nodes within this sub-tree
            nextNode = parseNode(); // Parse the next node
            // Add next node as child of current
            currentNode.children.push(nextNode);
            currentNode = nextNode; // Advance current pointer to this child
            white(); // Skip whitespace between/after sequence nodes
        }

        // Look for sub-trees of this sub-tree
        while (ch === "(") {
            nextNode = parseTree(); // Parse the next sub-tree
            // Add sub-tree as child of last sequence node
            currentNode.children.push(nextNode); // Do NOT advance current
            white(); // Skip whitespace between/after sub-trees
        }
        next(')'); // Expect closing parenthesis at end of this sub-tree

        return rootNode;
    }

    // Parses a node and its properties
    function parseNode() {
        var property, // Scratch for parsing properties
            node = {
                props: [],
                children: []
            }; // Node to construct

        next(';'); // Double-check semi-colon at start of node
        white(); // Skip whitespace before properties
        // Parse properties until end of node detected
        while (ch && ch !== ';' && ch !== '(' && ch !== ')') {
            property = parseProperty(); // Parse the property and values
            node.props.push(property); // Add property to node
            white(); // Skip whitespace between/after properties
        }

        return node;
    }

    // Parses a property and its values
    function parseProperty() {
        var property = {
            id: '',
            values: []
        }; // Property to construct

        // Look for property ID within letters
        while (ch && /[A-Za-z]/.test(ch)) {
            if (/[A-Z]/.test(ch)) { // Ignores lower case letters
                property.id += ch; // Only adds upper case letters
            }
            next();
        }
        if (!property.id) { // Error if id empty
            error('Missing property ID');
        }

        white(); // Skip whitespace before values
        while (ch === '[') { // Look for values of this property
            property.values.push(parseValue());
            white(); // Skip whitespace between/after values
        }
        if (property.values.length === 0) { // Error on empty list of values
            error('Missing property values');
        }

        return property;
    }

    // Parses a value
    function parseValue() {
        var value = '';
        next('['); // Double-check opening bracket at start of value

        // Read until end of value (unescaped closing bracket)
        while (ch && ch !== ']') {
            if (ch === '\\') { // Backslash escape handling
                next('\\');
                if (lineBreak()) { // Soft (escaped) line break
                    // Nothing, soft line breaks are removed
                } else if (ch <= ' ') { // Other whitespace
                    value += ' '; // Convert to space
                } else {
                    value += ch; // Pass other escaped characters verbatim
                }
            } else { // Non-escaped character
                if (lineBreak()) { // Hard (non-escaped) line break
                    value += '\n'; // Convert all new lines to just LF
                } else if (ch <= ' ') { // Other whitespace
                    value += ' '; // Convert to space
                } else {
                    value += ch; // Other characters
                }
            }
            next();
        }
        next(']'); // Expect closing bracket at end of value

        return value;
    }
};
// Convert game state tree into SGF string
besogo.composeSgf = function(editor) {
    'use strict';
    return '(' + composeNode(editor.getRoot()) + ')';

    // Recursively composes game node tree
    function composeNode(tree) {
        var string = ';', // Node starts with semi-colon
            children = tree.children,
            i; // Scratch iteration variable

        if (!tree.parent) { // Null parent means node is root
            // Compose root-specific properties
            string += composeRootProps(tree);
        }
        string += composeNodeProps(tree); // Compose general properties

        // Recurse composition on child nodes
        if (children.length === 1) { // Continue sequence if only one child
            string += '\n' + composeNode(children[0]);
        } else if (children.length > 1) {
            for (i = 0; i < children.length; i++) {
                string += '\n(' + composeNode(children[i]) + ')';
            }
        }

        return string;
    }

    // Composes root specific properties
    function composeRootProps(tree) {
        var string = 'FF[4]GM[1]CA[UTF-8]AP[besogo:' + besogo.VERSION + ']',
            x = tree.getSize().x,
            y = tree.getSize().y,
            gameInfo = editor.getGameInfo(), // Game info structure
            hasGameInfo = false, // Flag for existence of game info
            id; // Scratch iteration variable

        if (x === y) { // Square board size
            string += 'SZ[' + x + ']';
        } else { // Non-square board size
            string += 'SZ[' + x + ':' + y + ']';
        }
        string += 'ST[' + editor.getVariantStyle() + ']\n'; // Line break after header

        for (id in gameInfo) { // Compose game info properties
            if (gameInfo.hasOwnProperty(id) && gameInfo[id]) { // Skip empty strings
                string += id + '[' + escapeText(gameInfo[id]) + ']';
                hasGameInfo = true;
            }
        }
        string += (hasGameInfo ? '\n' : ''); // Line break if game info exists

        return string;
    }

    // Composes other properties
    function composeNodeProps(node) {
        var string = '',
            props, // Scratch variable for property structures
            stone, i, j; // Scratch iteration variables

        // Compose either move or setup properties depending on type of node
        if (node.getType() === 'move') { // Compose move properties
            stone = node.move;
            string += (stone.color === 1) ? 'W' : 'B';
            string += '[' + coordsToLetters(stone.x, stone.y) + ']';
        } else if (node.getType() === 'setup') { // Compose setup properties
            props = {
                AB: [],
                AW: [],
                AE: []
            };
            for (i = 1; i <= node.getSize().x; i++) {
                for (j = 1; j <= node.getSize().y; j++) {
                    stone = node.getSetup(i, j);
                    if (stone) { // If setup stone placed, add to structure
                        props[stone].push({
                            x: i,
                            y: j
                        });
                    }
                }
            }
            string += composePointLists(props);
        }

        // Compose markup properties
        props = {
            CR: [],
            SQ: [],
            TR: [],
            MA: [],
            SL: [],
            LB: []
        };
        for (i = 1; i <= node.getSize().x; i++) {
            for (j = 1; j <= node.getSize().y; j++) {
                stone = node.getMarkup(i, j);
                if (stone) { // If markup placed
                    if (typeof stone === 'string') { // String is label mark
                        props.LB.push({
                            x: i,
                            y: j,
                            label: stone
                        });
                    } else { // Numerical code for markup
                        // Convert numerical code to property ID
                        stone = (['CR', 'SQ', 'TR', 'MA', 'SL'])[stone - 1];
                        props[stone].push({
                            x: i,
                            y: j
                        });
                    }
                }
            }
        }
        string += composePointLists(props);

        if (node.comment) { // Compose comment property
            string += (string ? '\n' : ''); // Add line break if other properties exist
            string += 'C[' + escapeText(node.comment) + ']';
        }

        return string;
    } // END function composeNodeProps

    // Composes properties from structure of point lists
    // Each member should be an array of points for property ID = key
    // Each point should specify point with (x, y) and may have optional label
    function composePointLists(lists) {
        var string = '',
            id, points, i; // Scratch iteration variables

        for (id in lists) { // Object own keys specifies property IDs
            if (lists.hasOwnProperty(id)) {
                points = lists[id]; // Corresponding members are point lists
                if (points.length > 0) { // Only add property if list non-empty
                    string += id;
                    for (i = 0; i < points.length; i++) {
                        string += '[' + coordsToLetters(points[i].x, points[i].y);
                        if (points[i].label) { // Add optional composed label
                            string += ':' + escapeText(points[i].label);
                        }
                        string += ']';
                    }
                }
            }
        }
        return string;
    }

    // Escapes backslash and close bracket for text output
    function escapeText(input) {
        input = input.replace(/\\/g, '\\\\'); // Escape backslash
        return input.replace(/\]/g, '\\]'); // Escape close bracket
    }

    // Converts numerical coordinates to letters
    function coordsToLetters(x, y) {
        if (x === 0 || y === 0) {
            return '';
        } else {
            return numToChar(x) + numToChar(y);
        }
    }

    function numToChar(num) { // Helper for coordsToLetters
        if (num > 26) { // Numbers 27-52 to A-Z
            return String.fromCharCode('A'.charCodeAt(0) + num - 27);
        } else { // Numbers 1-26 to a-z
            return String.fromCharCode('a'.charCodeAt(0) + num - 1);
        }
    }
};
(function() {
    'use strict';

    // Color palette
    besogo.RED = '#be0119'; // Darker red (marked variant)
    besogo.LRED = '#ff474c'; // Lighter red (auto-marked variant)
    besogo.BLUE = '#0165fc'; // Bright blue (last move)
    besogo.PURP = '#9a0eea'; // Red + blue (variant + last move)
    besogo.GREY = '#929591'; // Between white and black
    besogo.GOLD = '#dbb40c'; // Tool selection
    besogo.TURQ = '#06c2ac'; // Turqoise (nav selection)

    besogo.BLACK_STONES = 4; // Number of black stone images
    besogo.WHITE_STONES = 11; // Number of white stone images

    // Makes an SVG element with given name and attributes
    besogo.svgEl = function(name, attributes) {
        var attr, // Scratch iteration variable
            element = document.createElementNS("http://www.w3.org/2000/svg", name);

        for (attr in (attributes || {})) { // Add attributes if supplied
            if (attributes.hasOwnProperty(attr)) {
                element.setAttribute(attr, attributes[attr]);
            }
        }
        return element;
    };

    // Makes an SVG group for containing the shadow layer
    besogo.svgShadowGroup = function() {
        var group = besogo.svgEl('g'),
            filter = besogo.svgEl('filter', {
                id: 'blur'
            }),
            blur = besogo.svgEl('feGaussianBlur', {
                in: 'SourceGraphic',
                stdDeviation: '2'
            });

        filter.appendChild(blur);
        group.appendChild(filter);
        return group;
    };

    // Makes a stone shadow
    besogo.svgShadow = function(x, y) {
        return besogo.svgEl("circle", {
            cx: x,
            cy: y,
            r: 43,
            stroke: 'none',
            fill: 'black',
            opacity: 0.32,
            filter: 'url(#blur)'
        });
    };

    // Makes a photo realistic stone element
    besogo.realStone = function(x, y, color, index) {
        var element;

        if (color < 0) {
            color = 'black' + (index % besogo.BLACK_STONES);
        } else {
            color = 'white' + (index % besogo.WHITE_STONES);
        }
        color = '_' + color + '.png';

        element = besogo.svgEl("image", {
            x: (x - 44),
            y: (y - 44),
            height: 88,
            width: 88
        });
        element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', color);

        return element;
    };

    // Makes a stone element
    besogo.svgStone = function(x, y, color) {
        var className = "besogo-svg-greyStone"; // Grey stone by default

        if (color === -1) { // Black stone
            className = "besogo-svg-blackStone";
        } else if (color === 1) { // White stone
            className = "besogo-svg-whiteStone";
        }

        return besogo.svgEl("circle", {
            cx: x,
            cy: y,
            r: 42,
            'class': className
        });
    };

    // Makes a circle at (x, y)
    besogo.svgCircle = function(x, y, color, strokeWidth) {
        return besogo.svgEl("circle", {
            cx: x,
            cy: y,
            r: 46,
            stroke: color,
            "stroke-width": strokeWidth || 8,
            fill: "none"
        });
    };

    // Makes a square at (x, y)
    besogo.svgSquare = function(x, y, color) {
        return besogo.svgEl("rect", {
            x: (x - 23),
            y: (y - 23),
            width: 46,
            height: 46,
            stroke: color,
            "stroke-width": 8,
            fill: "none"
        });
    };

    // Makes an equilateral triangle at (x, y)
    besogo.svgTriangle = function(x, y, color) {
        // Approximates an equilateral triangle centered on (x, y)
        var pointString = "" + x + "," + (y - 30) + " " +
            (x - 26) + "," + (y + 15) + " " +
            (x + 26) + "," + (y + 15);

        return besogo.svgEl("polygon", {
            points: pointString,
            stroke: color,
            "stroke-width": 8,
            fill: "none"
        });
    };

    // Makes an "X" cross at (x, y)
    besogo.svgCross = function(x, y, color) {
        var path = "m" + (x - 24) + "," + (y - 24) + "l48,48m0,-48l-48,48";

        return besogo.svgEl("path", {
            d: path,
            stroke: color,
            "stroke-width": 8,
            fill: "none"
        });
    };

    // Makes an "+" plus sign at (x, y)
    besogo.svgPlus = function(x, y, color) {
        var path = "m" + x + "," + (y - 28) + "v56m-28,-28h56";

        return besogo.svgEl("path", {
            d: path,
            stroke: color,
            "stroke-width": 8,
            fill: "none"
        });
    };

    // Makes a small filled square at (x, y)
    besogo.svgBlock = function(x, y, color) {
        return besogo.svgEl("rect", {
            x: x - 18,
            y: y - 18,
            width: 36,
            height: 36,
            stroke: "none",
            "stroke-width": 8,
            fill: color
        });
    };

    // Makes a label at (x, y)
    besogo.svgLabel = function(x, y, color, label) {
        var element,
            size;

        // Trims label to 3 characters
        if (label.length > 3) {
            label = label.slice(0, 2) + '';
        }

        // Set font size according to label length
        switch (label.length) {
            case 1:
                size = 72;
                break;
            case 2:
                size = 56;
                break;
            case 3:
                size = 36;
                break;
        }

        element = besogo.svgEl("text", {
            x: x,
            y: y,
            dy: ".65ex", // Seems to work for vertically centering these fonts
            "font-size": size,
            "text-anchor": "middle", // Horizontal centering
            "font-family": "Helvetica, Arial, sans-serif",
            fill: color
        });
        element.appendChild(document.createTextNode(label));

        return element;
    };

})(); // END closure
besogo.makeToolPanel = function(container, editor) {
    'use strict';
    var element, // Scratch for building SVG images
        svg, // Scratch for building SVG images
        labelText, // Text area for next label input
        selectors = {}, // Holds selection rects
        passButton = document.createElement('input'),
        cutButton = document.createElement('input');

    svg = makeButtonSVG('auto', 'Auto-play/nav'); // Auto-play/nav tool button
    svg.appendChild(makeYinYang(0, 0));

    svg = makeButtonSVG('playB', 'Play black'); // Play black button
    svg.appendChild(besogo.svgStone(0, 0, -1));

    svg = makeButtonSVG('playW', 'Play white'); // Play white button
    svg.appendChild(besogo.svgStone(0, 0, 1));

    svg = makeButtonSVG('addB', 'Set black'); // Add black button
    element = besogo.svgEl('g');
    element.appendChild(besogo.svgStone(0, 0, -1)); // Black stone
    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus
    svg.appendChild(element);

    svg = makeButtonSVG('addW', 'Set white'); // Add white button
    element = besogo.svgEl('g');
    element.appendChild(besogo.svgStone(0, 0, 1)); // White stone
    element.appendChild(besogo.svgPlus(0, 0, besogo.RED)); // Red plus
    svg.appendChild(element);

    svg = makeButtonSVG('addE', 'Set empty'); // Add empty button
    element = besogo.svgEl('g');
    element.appendChild(besogo.svgStone(0, 0)); // Grey stone
    element.appendChild(besogo.svgCross(0, 0, besogo.RED)); // Red cross
    svg.appendChild(element);

    svg = makeButtonSVG('circle', 'Circle'); // Circle markup button
    svg.appendChild(besogo.svgCircle(0, 0, 'black'));

    svg = makeButtonSVG('square', 'Square'); // Square markup button
    svg.appendChild(besogo.svgSquare(0, 0, 'black'));

    svg = makeButtonSVG('triangle', 'Triangle'); // Triangle markup button
    svg.appendChild(besogo.svgTriangle(0, 0, 'black'));

    svg = makeButtonSVG('cross', 'Cross'); // Cross markup button
    svg.appendChild(besogo.svgCross(0, 0, 'black'));

    svg = makeButtonSVG('block', 'Block'); // Block markup button
    svg.appendChild(besogo.svgBlock(0, 0, 'black'));

    svg = makeButtonSVG('clrMark', 'Clear mark'); // Clear markup button
    element = besogo.svgEl('g');
    element.appendChild(besogo.svgTriangle(0, 0, besogo.GREY));
    element.appendChild(besogo.svgCross(0, 0, besogo.RED));
    svg.appendChild(element);

    svg = makeButtonSVG('label', 'Label'); // Label markup button
    svg.appendChild(besogo.svgLabel(0, 0, 'black', 'A1'));

    labelText = document.createElement("input"); // Label entry text field
    labelText.type = "text";
    labelText.title = 'Next label';
    labelText.onblur = function() {
        editor.setLabel(labelText.value);
    };
    labelText.addEventListener('keydown', function(evt) {
        evt = evt || window.event;
        evt.stopPropagation(); // Stop keydown propagation when in focus
    });
    container.appendChild(labelText);

    passButton.type = 'button';
    passButton.value = 'Pass';
    passButton.title = 'Pass move';
    passButton.onclick = function() {
        var tool = editor.getTool();
        if (tool !== 'navOnly' && tool !== 'auto' && tool !== 'playB' && tool !== 'playW') {
            editor.setTool('auto'); // Ensures that a move tool is selected
        }
        editor.click(0, 0, false); // Clicking off the board signals a pass
    };
    container.appendChild(passButton);

    cutButton.type = 'button';
    cutButton.value = 'Cut';
    cutButton.title = 'Remove branch';
    cutButton.onclick = function() {
        editor.cutCurrent();
    };
    container.appendChild(cutButton);

    editor.addListener(toolStateUpdate); // Set up listener for tool state updates
    toolStateUpdate({
        label: editor.getLabel(),
        tool: editor.getTool()
    }); // Initialize

    // Creates a button holding an SVG image
    function makeButtonSVG(tool, tooltip) {
        var button = document.createElement('button'),
            svg = besogo.svgEl('svg', { // Icon container
                width: '100%',
                height: '100%',
                viewBox: '-55 -55 110 110'
            }), // Centered on (0, 0)
            selected = besogo.svgEl("rect", { // Selection rectangle
                x: -50, // Center on (0, 0)
                y: -50,
                width: 100,
                height: 100,
                fill: 'none',
                'stroke-width': 8,
                stroke: besogo.GOLD,
                rx: 20, // Rounded rectangle
                ry: 20, // Thanks, Steve
                visibility: 'hidden'
            });

        container.appendChild(button);
        button.appendChild(svg);
        button.onclick = function() {
            editor.setTool(tool);
        };
        button.title = tooltip;
        selectors[tool] = selected;
        svg.appendChild(selected);
        return svg; // Returns reference to the icon container
    }

    // Callback for updating tool state and label
    function toolStateUpdate(msg) {
        var tool;
        if (msg.label) {
            labelText.value = msg.label;
        }
        if (msg.tool) {
            for (tool in selectors) { // Update which tool is selected
                if (selectors.hasOwnProperty(tool)) {
                    if (msg.tool === tool) {
                        selectors[tool].setAttribute('visibility', 'visible');
                    } else {
                        selectors[tool].setAttribute('visibility', 'hidden');
                    }
                }
            }
        }
    }

    // Draws a yin yang
    function makeYinYang(x, y) {
        var element = besogo.svgEl('g');

        // Draw black half circle on right side
        element.appendChild(besogo.svgEl("path", {
            d: "m" + x + "," + (y - 44) + " a44 44 0 0 1 0,88z",
            stroke: "none",
            fill: "black"
        }));

        // Draw white part of ying yang on left side
        element.appendChild(besogo.svgEl("path", {
            d: "m" + x + "," + (y + 44) + "a44 44 0 0 1 0,-88a22 22 0 0 1 0,44z",
            stroke: "none",
            fill: "white"
        }));

        // Draw round part of black half of ying yang
        element.appendChild(besogo.svgEl("circle", {
            cx: x,
            cy: y + 22,
            r: 22,
            stroke: "none",
            fill: "black"
        }));

        return element;
    }
};
besogo.makeTreePanel = function(container, editor) {
    'use strict';
    var svg,
        pathGroup,
        bottomLayer,
        currentMarker,
        SCALE = 0.25; // Tree size scaling factor

    rebuildNavTree();
    editor.addListener(treeUpdate);

    // Callback for handling tree changes
    function treeUpdate(msg) {
        if (msg.treeChange) { // Tree structure changed
            rebuildNavTree(); // Rebuild entire tree
        } else if (msg.navChange) { // Only navigation changed
            updateCurrentMarker(); // Update current location marker
        } else if (msg.stoneChange) { // Only stones in current changed
            updateCurrentNodeIcon();
        }
    }

    // Updates the current marker in the tree
    function updateCurrentMarker() {
        var current = editor.getCurrent();

        setSelectionMarker(currentMarker);
        setCurrentMarker(current.navTreeMarker);
    }

    // Sets marker element to indicate the current node
    function setCurrentMarker(marker) {
        var width = container.clientWidth,
            height = container.clientHeight,
            top = container.scrollTop,
            left = container.scrollLeft,
            markX = (marker.getAttribute('x') - 5) * SCALE, // Computed position of marker
            markY = (marker.getAttribute('y') - 5) * SCALE,
            GRIDSIZE = 120 * SCALE; // Size of the square grid

        if (markX < left) { // Ensure horizontal visibility of current marker
            container.scrollLeft = markX;
        } else if (markX + GRIDSIZE > left + width) {
            container.scrollLeft = markX + GRIDSIZE - width;
        }
        if (markY < top) { // Ensure vertical visibility of current marker
            container.scrollTop = markY;
        } else if (markY + GRIDSIZE > top + height) {
            container.scrollTop = markY + GRIDSIZE - height;
        }

        marker.setAttribute('opacity', 1); // Always visible
        marker.onmouseover = null; // Clear hover over action
        marker.onmouseout = null; // Clear hover off action
        bottomLayer.appendChild(marker); // Moves marker to the background
        currentMarker = marker;
    }

    // Sets marker
    function setSelectionMarker(marker) {
        marker.setAttribute('opacity', 0); // Normally invisible
        marker.onmouseover = function() { // Show on hover over
            marker.setAttribute('opacity', 0.5);
        };
        marker.onmouseout = function() { // Hide on hover off
            marker.setAttribute('opacity', 0);
        };
        svg.appendChild(marker); // Move marker to foreground
    }

    // Rebuilds the entire navigation tree
    function rebuildNavTree() {
        var current = editor.getCurrent(), // Current location in game state tree
            root = editor.getRoot(), // Root node of game state
            nextOpen = [], // Tracks occupied grid positions
            oldSvg = svg, // Store the old SVG root
            background = besogo.svgEl("rect", { // Background color for tree
                height: '100%',
                width: '100%',
                'class': 'besogo-svg-board'
            }),
            path, // Root path
            width, // Calculated dimensions of the SVG
            height;

        markCorrectPaths(root); // Pre-pass to mark nodes on correct paths

        svg = besogo.svgEl("svg");
        bottomLayer = besogo.svgEl("g"); // Holder for the current marker
        pathGroup = besogo.svgEl("g"); // Holder for path elements

        svg.appendChild(background); // Background color first
        svg.appendChild(bottomLayer); // Bottom layer (for current marker) second
        svg.appendChild(pathGroup); // Navigation path third

        path = recursiveTreeBuild(root, 0, 0, nextOpen); // Build the tree
        pathGroup.appendChild(finishPath(path, 'black')); // Finish and add root path

        width = 120 * nextOpen.length; // Compute height and width of nav tree
        height = 120 * Math.max.apply(Math, nextOpen);
        svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
        svg.setAttribute('height', height * SCALE); // Scale down the actual SVG size
        svg.setAttribute('width', width * SCALE);

        if (oldSvg) { // Replace SVG in container
            container.replaceChild(svg, oldSvg);
        } else { // SVG not yet added to container
            container.appendChild(svg);
        }

        setCurrentMarker(current.navTreeMarker); // Set current marker and ensure visible

        function markCorrectPaths(node) {
            let isCorrect = false;
            if (node.children.length === 0) {
                isCorrect = checkComment(node.comment) === 1;
            } else {
                for (let i = 0; i < node.children.length; i++) {
                    if (markCorrectPaths(node.children[i])) {
                        isCorrect = true;
                    }
                }
            }
            node.isOnCorrectPath = isCorrect;
            return isCorrect;
        }
    } // END function rebuildNavTree

    // Recursively builds the tree
    function recursiveTreeBuild(node, x, y, nextOpen) {
        var children = node.children,
            position,
            path,
            childPath,
            i; // Scratch iteration variables

        if (children.length === 0) { // Reached end of branch
            path = 'm' + svgPos(x) + ',' + svgPos(y); // Start path at end of branch
        } else { // Current node has children
            position = (nextOpen[x + 1] || 0); // First open spot in next column
            position = (position < y) ? y : position; // Bring level with current y

            if (y < position - 1) { // Check if first child natural drop > 1
                y = position - 1; // Bring current y within 1 of first child drop
            }
            // Place first child and extend path
            path = recursiveTreeBuild(children[0], x + 1, position, nextOpen) +
                extendPath(x, y, nextOpen);

            // Place other children (intentionally starting at i = 1)
            for (i = 1; i < children.length; i++) {
                position = nextOpen[x + 1];
                childPath = recursiveTreeBuild(children[i], x + 1, position, nextOpen) +
                    extendPath(x, y, nextOpen, position - 1);
                // End path at beginning of branch
                pathGroup.appendChild(finishPath(childPath, 'black'));
            }
        }
        svg.appendChild(makeNodeIcon(node, x, y));
        addSelectionMarker(node, x, y);

        nextOpen[x] = y + 1; // Claims (x, y)
        return path;
    } // END function recursiveTreeBuild

    function makeNodeIcon(node, x, y) { // Makes a node icon for the tree
        var element,
            color;

        switch (node.getType()) {
            case 'move': // Move node
                color = node.move.color;
                element = besogo.svgEl("g");
                element.appendChild(besogo.svgStone(svgPos(x), svgPos(y), color));
                color = (color === -1) ? "white" : "black";
                element.appendChild(besogo.svgLabel(svgPos(x), svgPos(y), color,
                    '' + node.moveNumber));
                break;
            case 'setup': // Setup node
                element = besogo.svgEl("g");
                element.appendChild(besogo.svgStone(svgPos(x), svgPos(y))); // Grey stone
                element.appendChild(besogo.svgPlus(svgPos(x), svgPos(y), besogo.RED));
                break;
            default: // Empty node
                element = besogo.svgStone(svgPos(x), svgPos(y)); // Grey stone
        }

        // Highlight all nodes on paths leading to a correct leaf
        if (node.isOnCorrectPath) {
            if (node.getType() !== 'move' && node.getType() !== 'setup') {
                // If it was just a grey stone (empty node), make it a group so we can add the circle
                let g = besogo.svgEl("g");
                g.appendChild(element);
                element = g;
            }
            let isCorrectLeaf = (node.children.length === 0); // Correctness already checked by isOnCorrectPath
            element.appendChild(besogo.svgCircle(svgPos(x), svgPos(y), 'limegreen', isCorrectLeaf ? 16 : 8));
        }

        node.navTreeIcon = element; // Save icon reference in game state tree
        node.navTreeX = x; // Save position of the icon
        node.navTreeY = y;

        return element;
    } // END function makeNodeIcon

    function updateCurrentNodeIcon() { // Updates the current node icon
        var current = editor.getCurrent(), // Current location in game state tree
            oldIcon = current.navTreeIcon,
            newIcon = makeNodeIcon(current, current.navTreeX, current.navTreeY);
        svg.replaceChild(newIcon, oldIcon);
    }

    function addSelectionMarker(node, x, y) {
        var element = besogo.svgEl("rect", { // Create selection marker
            x: svgPos(x) - 55,
            y: svgPos(y) - 55,
            width: 110,
            height: 110,
            fill: besogo.TURQ
        });
        element.onclick = function() {
            editor.setCurrent(node);
        };

        node.navTreeMarker = element; // Save selection marker in node
        setSelectionMarker(element); // Add as and set selection marker properties
    }

    function extendPath(x, y, nextOpen, prevChildPos) { // Extends path from child to current
        var childPos = nextOpen[x + 1] - 1; // Position of child
        if (childPos === y) { // Child is horizontally level with current
            return 'h-120'; // Horizontal line back to current
        } else if (childPos === y + 1) { // Child is one drop from current
            return 'l-120,-120'; // Diagonal drop line back to current
        } else if (prevChildPos && prevChildPos !== y) {
            // Previous is already dropped, extend back to previous child drop line
            return 'l-60,-60v-' + (120 * (childPos - prevChildPos));
        } else { // Extend double-bend drop line back to parent
            return 'l-60,-60v-' + (120 * (childPos - y - 1)) + 'l-60,-60';
        }
    }

    function finishPath(path, color) { // Finishes path element
        var element = besogo.svgEl("path", {
            d: path,
            stroke: (color === 'black') ? 'currentColor' : color,
            "stroke-width": 8,
            fill: "none"
        });
        return element;
    }

    function svgPos(x) { // Converts (x, y) coordinates to SVG position
        return (x * 120) + 60;
    }
};

besogo.autoInit();

if (goFirst == false) {				
var myTimeout = setTimeout(nextMove, 200);
}

document.getElementsByClassName("besogo-board")[0].style.border = "max(0.7vmin, 6px) solid " + solvedColour;
document.getElementsByClassName("besogo-board")[0].style.boxShadow ="0px 0px 6px 0px " + solvedColour;

</script>